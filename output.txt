This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: **/*.log, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/uv.lock, **/package-lock.json, **/.env, **/Cargo.lock, **/node_modules, **/target, **/dist, **/build, **/output.txt, **/yarn.lock, **/.private-journal
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    .gitkeep
    ci.yml
    release.yml
  dependabot.yml
docs/
  examples/
    matrix-bridge/
      .env.example
      .gitignore
      .python-version
      main.py
      pyproject.toml
      README.md
      requirements.txt
    simple-tui/
      index.js
      package.json
      README.md
      tui.py
  plans/
    2025-12-02-matrix-claude-bridge-design.md
    2025-12-02-matrix-claude-bridge-implementation.md
    2025-12-03-github-actions-cicd-design.md
    2025-12-03-github-actions-cicd-implementation.md
  testing.md
src/
  claude.rs
  config.rs
  lib.rs
  main.rs
  matrix_client.rs
  message_handler.rs
  session.rs
  webhook.rs
tests/
  claude_tests.rs
  config_tests.rs
  session_tests.rs
.dockerignore
.env.example
.gitignore
Cargo.toml
code-review.md
config.toml.example
docker-compose.yml
DOCKER.md
Dockerfile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/webhook.rs">
  1: // ABOUTME: HTTP webhook server for injecting prompts into Claude sessions
  2: // ABOUTME: Provides POST /webhook/session/:id endpoint for external triggers like cron jobs
  3: use anyhow::Result;
  4: use axum::{
  5:     extract::{Path, State},
  6:     http::StatusCode,
  7:     response::IntoResponse,
  8:     routing::post,
  9:     Json, Router,
 10: };
 11: use matrix_sdk::{
 12:     ruma::{events::room::message::RoomMessageEventContent, OwnedRoomId},
 13:     Client,
 14: };
 15: use serde::{Deserialize, Serialize};
 16: use std::sync::Arc;
 17: use tower_http::trace::TraceLayer;
 18: use crate::{claude, config::Config, session::SessionStore};
 19: #[derive(Clone)]
 20: pub struct WebhookState {
 21:     pub session_store: SessionStore,
 22:     pub matrix_client: Client,
 23:     pub config: Arc<Config>,
 24: }
 25: #[derive(Debug, Deserialize)]
 26: pub struct WebhookRequest {
 27:     pub prompt: String,
 28:     #[serde(skip_serializing_if = "Option::is_none")]
 29:     pub api_key: Option<String>,
 30: }
 31: #[derive(Debug, Serialize)]
 32: pub struct WebhookResponse {
 33:     pub success: bool,
 34:     pub message: String,
 35: }
 36: /// Start the webhook HTTP server
 37: pub async fn start_webhook_server(
 38:     port: u16,
 39:     session_store: SessionStore,
 40:     matrix_client: Client,
 41:     config: Arc<Config>,
 42: ) -> Result<()> {
 43:     let state = WebhookState {
 44:         session_store,
 45:         matrix_client,
 46:         config,
 47:     };
 48:     let app = Router::new()
 49:         .route("/webhook/session/:session_id", post(webhook_handler))
 50:         .layer(TraceLayer::new_for_http())
 51:         .with_state(Arc::new(state));
 52:     let addr = format!("127.0.0.1:{}", port);
 53:     tracing::info!(addr = %addr, "Starting webhook server");
 54:     let listener = tokio::net::TcpListener::bind(&addr).await?;
 55:     axum::serve(listener, app).await?;
 56:     Ok(())
 57: }
 58: /// Handle webhook POST requests
 59: async fn webhook_handler(
 60:     State(state): State<Arc<WebhookState>>,
 61:     Path(session_id): Path<String>,
 62:     Json(payload): Json<WebhookRequest>,
 63: ) -> impl IntoResponse {
 64:     tracing::info!(
 65:         session_id = %session_id,
 66:         prompt_preview = %payload.prompt.chars().take(50).collect::<String>(),
 67:         "Webhook received"
 68:     );
 69:     // Validate API key if configured
 70:     if let Some(expected_key) = &state.config.webhook.api_key {
 71:         match &payload.api_key {
 72:             Some(provided_key) if provided_key == expected_key => {
 73:                 // Valid key, continue
 74:             }
 75:             _ => {
 76:                 tracing::warn!(session_id = %session_id, "Webhook authentication failed");
 77:                 return (
 78:                     StatusCode::UNAUTHORIZED,
 79:                     Json(WebhookResponse {
 80:                         success: false,
 81:                         message: "Invalid or missing API key".to_string(),
 82:                     }),
 83:                 );
 84:             }
 85:         }
 86:     }
 87:     // Validate prompt is not empty
 88:     if payload.prompt.trim().is_empty() {
 89:         tracing::warn!(session_id = %session_id, "Webhook received empty prompt");
 90:         return (
 91:             StatusCode::BAD_REQUEST,
 92:             Json(WebhookResponse {
 93:                 success: false,
 94:                 message: "Prompt cannot be empty".to_string(),
 95:             }),
 96:         );
 97:     }
 98:     // Look up channel by session ID
 99:     let channel = match state.session_store.get_by_session_id(&session_id) {
100:         Ok(Some(c)) => c,
101:         Ok(None) => {
102:             tracing::warn!(session_id = %session_id, "Session not found");
103:             return (
104:                 StatusCode::NOT_FOUND,
105:                 Json(WebhookResponse {
106:                     success: false,
107:                     message: format!("Session not found: {}", session_id),
108:                 }),
109:             );
110:         }
111:         Err(e) => {
112:             tracing::error!(error = %e, "Database error");
113:             return (
114:                 StatusCode::INTERNAL_SERVER_ERROR,
115:                 Json(WebhookResponse {
116:                     success: false,
117:                     message: format!("Database error: {}", e),
118:                 }),
119:             );
120:         }
121:     };
122:     // Get Matrix room
123:     let room_id: OwnedRoomId = match channel.room_id.parse() {
124:         Ok(id) => id,
125:         Err(e) => {
126:             tracing::error!(error = %e, room_id = %channel.room_id, "Invalid room ID");
127:             return (
128:                 StatusCode::INTERNAL_SERVER_ERROR,
129:                 Json(WebhookResponse {
130:                     success: false,
131:                     message: format!("Invalid room ID: {}", e),
132:                 }),
133:             );
134:         }
135:     };
136:     let Some(room) = state.matrix_client.get_room(&room_id) else {
137:         tracing::warn!(room_id = %channel.room_id, "Room not found");
138:         return (
139:             StatusCode::NOT_FOUND,
140:             Json(WebhookResponse {
141:                 success: false,
142:                 message: format!("Room not found: {}", channel.room_id),
143:             }),
144:         );
145:     };
146:     // 1. Send webhook prompt to room for visibility
147:     if let Err(e) = room
148:         .send(RoomMessageEventContent::text_plain(&format!(
149:             "ü§ñ Webhook: {}",
150:             payload.prompt
151:         )))
152:         .await
153:     {
154:         tracing::error!(error = %e, "Failed to send webhook prompt to room");
155:         return (
156:             StatusCode::INTERNAL_SERVER_ERROR,
157:             Json(WebhookResponse {
158:                 success: false,
159:                 message: format!("Failed to send message: {}", e),
160:             }),
161:         );
162:     }
163:     // 2. Invoke Claude directly
164:     let claude_response = match claude::invoke_claude(
165:         &state.config.claude.binary_path,
166:         state.config.claude.sdk_url.as_deref(),
167:         channel.cli_args(),
168:         &payload.prompt,
169:         Some(&channel.directory),
170:     )
171:     .await
172:     {
173:         Ok(resp) => resp,
174:         Err(e) => {
175:             tracing::error!(error = %e, "Claude invocation failed");
176:             let error_msg = format!("‚ö†Ô∏è Claude error: {}", e);
177:             let _ = room
178:                 .send(RoomMessageEventContent::text_plain(&error_msg))
179:                 .await;
180:             return (
181:                 StatusCode::INTERNAL_SERVER_ERROR,
182:                 Json(WebhookResponse {
183:                     success: false,
184:                     message: format!("Claude error: {}", e),
185:                 }),
186:             );
187:         }
188:     };
189:     // 3. Send Claude's response to room
190:     if let Err(e) = room
191:         .send(RoomMessageEventContent::text_plain(&claude_response))
192:         .await
193:     {
194:         tracing::error!(error = %e, "Failed to send Claude response");
195:         return (
196:             StatusCode::INTERNAL_SERVER_ERROR,
197:             Json(WebhookResponse {
198:                 success: false,
199:                 message: format!("Failed to send response: {}", e),
200:             }),
201:         );
202:     }
203:     // 4. Mark session as started
204:     if let Err(e) = state.session_store.mark_started(&channel.room_id) {
205:         tracing::error!(error = %e, "Failed to mark session as started");
206:         // Don't fail the request - message was sent successfully
207:     }
208:     tracing::info!(
209:         session_id = %session_id,
210:         room_id = %channel.room_id,
211:         "Webhook processed successfully"
212:     );
213:     (
214:         StatusCode::OK,
215:         Json(WebhookResponse {
216:             success: true,
217:             message: "Message sent and Claude responded successfully".to_string(),
218:         }),
219:     )
220: }
</file>

<file path=".dockerignore">
1: target/
2: sessions_db/
3: crypto_store/
4: .env
5: .git/
6: .gitignore
7: README.md
8: *.md
</file>

<file path="code-review.md">
  1: # Code Review: Matrix-Claude Bridge
  2: 
  3: ## Overview
  4: 
  5: This is a comprehensive code review of a Rust-based Matrix bot that bridges conversations to Claude Code CLI. The codebase is well-structured with clear separation of concerns and good documentation.
  6: 
  7: ## Critical Issues
  8: 
  9: ### 1. Security Vulnerability: Auto-Confirmation of Device Verification (src/main.rs:125-129)
 10: **Severity: HIGH**
 11: 
 12: ```rust
 13: // Lines 125-129
 14: tracing::warn!("Auto-confirming in 5 seconds...");
 15: tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
 16: sas.confirm().await.expect("Can't confirm SAS verification");
 17: ```
 18: 
 19: **Issue:** The bot automatically confirms device verification without manual review of emojis. This completely undermines E2E encryption security and could allow man-in-the-middle attacks.
 20: 
 21: **Recommendation:** Remove auto-confirmation and require manual verification. Consider implementing a webhook or admin interface for verification approval.
 22: 
 23: ### 2. SQL Injection Risk: No Prepared Statement Validation (src/session.rs:62-80)
 24: **Severity: MEDIUM-HIGH**
 25: 
 26: While the code uses `params![]` macros which should prevent SQL injection, there's inconsistent error handling and the database operations lack transaction safety for multi-step operations.
 27: 
 28: **Recommendation:** Wrap multi-step database operations in transactions and add more robust error handling.
 29: 
 30: ### 3. Path Traversal Vulnerability (src/claude.rs:23-24)
 31: **Severity: MEDIUM**
 32: 
 33: ```rust
 34: // Lines 23-24
 35: if binary_path.contains("..") || binary_path.contains('\0') {
 36:     anyhow::bail!("Invalid claude binary path");
 37: }
 38: ```
 39: 
 40: **Issue:** The path validation is insufficient. It only checks for `..` and null bytes but doesn't validate the full path or prevent other forms of path traversal.
 41: 
 42: **Recommendation:** Use proper path canonicalization and whitelist allowed binary locations.
 43: 
 44: ## Design Issues
 45: 
 46: ### 4. Inconsistent Session Model (src/session.rs vs tests/session_tests.rs)
 47: **Severity: MEDIUM**
 48: 
 49: The session storage has evolved from a simple key-value model to a complex Channel-based model, but the tests still reference the old `Session` struct that no longer exists in the main code.
 50: 
 51: **Lines in tests/session_tests.rs:21-24:**
 52: ```rust
 53: let session = matrix_bridge::session::Session {
 54:     session_id: "test-uuid".to_string(),
 55:     started: false,
 56: };
 57: ```
 58: 
 59: **Issue:** Tests are testing non-existent code, making them useless for validation.
 60: 
 61: **Recommendation:** Update all tests to use the `Channel` model and ensure they test actual functionality.
 62: 
 63: ### 5. Race Condition in Typing Indicators (src/message_handler.rs:67-87)
 64: **Severity: MEDIUM**
 65: 
 66: The typing indicator management uses a complex spawned task with channels, but there's no guarantee of cleanup if the main task panics before sending the stop signal.
 67: 
 68: **Recommendation:** Use a `tokio::select!` pattern or ensure proper cleanup in error paths.
 69: 
 70: ### 6. Incomplete Error Context (src/claude.rs:44-50)
 71: **Severity: LOW-MEDIUM**
 72: 
 73: ```rust
 74: let output = command.output().await.with_context(|| {
 75:     if let Some(dir) = working_dir {
 76:         format!("Failed to spawn claude CLI in directory: {}", dir)
 77:     } else {
 78:         "Failed to spawn claude CLI".to_string()
 79:     }
 80: })?;
 81: ```
 82: 
 83: **Issue:** The error context doesn't include the command arguments or binary path, making debugging difficult.
 84: 
 85: ## Code Quality Issues
 86: 
 87: ### 7. Overly Complex Message Handler (src/message_handler.rs)
 88: **Severity: MEDIUM**
 89: 
 90: The `handle_message` function is 124 lines long and handles multiple concerns:
 91: - Authentication 
 92: - Command parsing
 93: - Channel management
 94: - Claude invocation
 95: - Error handling
 96: 
 97: **Recommendation:** Split into smaller, focused functions with single responsibilities.
 98: 
 99: ### 8. Magic Numbers and Hardcoded Values (Multiple files)
100: **Severity: LOW-MEDIUM**
101: 
102: ```rust
103: // src/main.rs:125
104: tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
105: 
106: // src/message_handler.rs:37
107: let message_preview: String = body.chars().take(50).collect();
108: 
109: // src/message_handler.rs:72
110: let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(25));
111: ```
112: 
113: **Recommendation:** Extract these as named constants with documentation explaining the chosen values.
114: 
115: ### 9. Inconsistent Error Handling Patterns (Multiple files)
116: **Severity: LOW**
117: 
118: Some functions use `anyhow::bail!`, others use `anyhow::Context`, and some use raw `Result<T, E>` returns. The error handling should be consistent across the codebase.
119: 
120: ### 10. Missing Input Validation (src/webhook.rs:57)
121: **Severity: LOW-MEDIUM**
122: 
123: ```rust
124: Json(payload): Json<WebhookRequest>,
125: ```
126: 
127: The webhook accepts arbitrary prompt strings without validation for length, content, or potential injection attacks.
128: 
129: **Recommendation:** Add input validation for prompt length, content filtering, and rate limiting.
130: 
131: ## Test Coverage Issues
132: 
133: ### 11. Broken Test Dependencies (tests/session_tests.rs:8)
134: **Severity: HIGH**
135: 
136: ```rust
137: let session1 = store.get_or_create(room_id).unwrap();
138: ```
139: 
140: **Issue:** The `get_or_create` method doesn't exist on `SessionStore`. The current API uses `get_by_room` and `create_channel` separately.
141: 
142: **Recommendation:** Rewrite all tests to match the current API surface.
143: 
144: ### 12. Inadequate Test Coverage (tests/ directory)
145: **Severity: MEDIUM**
146: 
147: Critical functionality like message handling, Matrix client operations, and webhook endpoints have no unit tests. Only basic configuration parsing and Claude response parsing are tested.
148: 
149: ## Documentation Issues
150: 
151: ### 13. Misleading Documentation (src/main.rs:47)
152: **Severity: LOW**
153: 
154: ```rust
155: tracing::info!("Bot ready - DM me to create Claude rooms!");
156: ```
157: 
158: The log message suggests the bot is ready to accept DMs, but the actual workflow is more complex and requires proper room setup.
159: 
160: ### 14. Missing API Documentation (src/webhook.rs)
161: **Severity: LOW**
162: 
163: The webhook endpoints lack OpenAPI/Swagger documentation and examples for integration.
164: 
165: ## Performance Issues
166: 
167: ### 15. Inefficient Database Queries (src/session.rs:142-161)
168: **Severity: LOW**
169: 
170: ```rust
171: pub fn list_all(&self) -> Result<Vec<Channel>> {
172:     let db = self.db.lock().unwrap();
173:     // ... fetches all channels without pagination
174: }
175: ```
176: 
177: **Issue:** No pagination support for listing channels, which could be problematic with many channels.
178: 
179: ## Positive Aspects
180: 
181: 1. **Good separation of concerns** with clear module boundaries
182: 2. **Comprehensive configuration management** with environment variable validation
183: 3. **Proper async/await usage** throughout the codebase
184: 4. **Good logging with structured tracing**
185: 5. **Docker support** with multi-stage builds
186: 6. **CI/CD pipeline** with proper caching and cross-platform builds
187: 
188: ## Recommendations Summary
189: 
190: 1. **Security**: Remove auto-verification and implement proper path validation
191: 2. **Testing**: Rewrite tests to match current API and add integration tests
192: 3. **Refactoring**: Split large functions and extract constants
193: 4. **Error Handling**: Standardize error handling patterns across modules
194: 5. **Documentation**: Add proper API documentation and improve inline docs
195: 
196: ## Overall Assessment
197: 
198: The codebase shows good architectural thinking and Rust best practices, but has significant security concerns and test coverage gaps that need immediate attention. The design is sound but needs refinement in implementation details.
199: 
200: **Priority:** Address security issues first, then fix broken tests, then tackle code quality improvements.
</file>

<file path="docker-compose.yml">
 1: # ABOUTME: Docker Compose configuration for Matrix-Claude bridge
 2: # ABOUTME: Manages volumes, environment variables, and restart policy
 3: version: '3.8'
 4: services:
 5:   matrix-bridge:
 6:     build: .
 7:     image: matrix-claude-bridge:latest
 8:     container_name: matrix-claude-bridge
 9:     restart: unless-stopped
10:     # Environment variables from .env file
11:     env_file:
12:       - .env
13:     # Persistent volumes for session and crypto data
14:     volumes:
15:       - ./sessions_db:/app/sessions_db
16:       - ./crypto_store:/app/crypto_store
17:       # Mount claude binary from host (optional - comment out if claude is in PATH)
18:       # - /usr/local/bin/claude:/usr/local/bin/claude:ro
19:     # Logging configuration
20:     logging:
21:       driver: "json-file"
22:       options:
23:         max-size: "10m"
24:         max-file: "3"
</file>

<file path="DOCKER.md">
  1: # Running Matrix-Claude Bridge in Docker
  2: 
  3: ## Quick Start
  4: 
  5: ### 1. Build the image
  6: 
  7: ```bash
  8: docker-compose build
  9: ```
 10: 
 11: ### 2. Configure environment variables
 12: 
 13: Make sure your `.env` file has the required variables:
 14: 
 15: ```bash
 16: MATRIX_HOME_SERVER=https://matrix.org
 17: MATRIX_USER_ID=@yourbot:matrix.org
 18: MATRIX_PASSWORD=your_password
 19: ALLOWED_USERS=@youruser:matrix.org
 20: CLAUDE_BINARY_PATH=/usr/local/bin/claude
 21: ```
 22: 
 23: ### 3. Run the container
 24: 
 25: ```bash
 26: docker-compose up -d
 27: ```
 28: 
 29: ### 4. View logs
 30: 
 31: ```bash
 32: docker-compose logs -f
 33: ```
 34: 
 35: ## Important: Claude CLI Access
 36: 
 37: The bot needs access to the Claude CLI binary. You have two options:
 38: 
 39: ### Option 1: Mount Claude from host (Recommended)
 40: 
 41: Uncomment this line in `docker-compose.yml`:
 42: 
 43: ```yaml
 44: volumes:
 45:   - /usr/local/bin/claude:/usr/local/bin/claude:ro
 46: ```
 47: 
 48: Replace `/usr/local/bin/claude` with your actual claude binary path.
 49: 
 50: Find your claude path:
 51: ```bash
 52: which claude
 53: ```
 54: 
 55: ### Option 2: Install Claude in the container
 56: 
 57: Add this to the Dockerfile after the `FROM debian:bookworm-slim` line:
 58: 
 59: ```dockerfile
 60: # Install Node.js (if claude needs it)
 61: RUN apt-get update && apt-get install -y curl && \
 62:     curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
 63:     apt-get install -y nodejs && \
 64:     npm install -g @anthropic-ai/claude-cli
 65: ```
 66: 
 67: ## Persistent Data
 68: 
 69: The following directories are persisted as volumes:
 70: - `./sessions_db` - Claude session data
 71: - `./crypto_store` - Matrix encryption keys
 72: 
 73: ## Useful Commands
 74: 
 75: ```bash
 76: # Stop the container
 77: docker-compose down
 78: 
 79: # Rebuild after code changes
 80: docker-compose up -d --build
 81: 
 82: # View container status
 83: docker-compose ps
 84: 
 85: # Execute commands in container
 86: docker-compose exec matrix-bridge /bin/bash
 87: 
 88: # Remove everything (including volumes)
 89: docker-compose down -v
 90: ```
 91: 
 92: ## Troubleshooting
 93: 
 94: ### Container can't find claude binary
 95: 
 96: Check if claude is mounted correctly:
 97: ```bash
 98: docker-compose exec matrix-bridge which claude
 99: ```
100: 
101: ### Permission errors with volumes
102: 
103: The container runs as the `claude` user (UID 1000). If you have permission issues:
104: ```bash
105: sudo chown -R 1000:1000 sessions_db crypto_store
106: ```
107: 
108: ### View detailed logs
109: 
110: ```bash
111: docker-compose logs -f --tail=100
112: ```
</file>

<file path="Dockerfile">
 1: # ABOUTME: Multi-stage Dockerfile for Matrix-Claude bridge
 2: # ABOUTME: Builds Rust binary and creates minimal runtime image with proper user permissions
 3: 
 4: # Build stage
 5: FROM rustlang/rust:nightly-bookworm as builder
 6: 
 7: WORKDIR /app
 8: 
 9: # Copy manifests
10: COPY Cargo.toml Cargo.lock ./
11: 
12: # Copy source code
13: COPY src ./src
14: 
15: # Build release binary
16: RUN cargo build --release
17: 
18: # Runtime stage
19: FROM debian:bookworm-slim
20: 
21: # Install runtime dependencies
22: RUN apt-get update && apt-get install -y \
23:     ca-certificates \
24:     libssl3 \
25:     && rm -rf /var/lib/apt/lists/*
26: 
27: # Create non-root user
28: RUN useradd --create-home --shell /bin/bash claude
29: 
30: WORKDIR /app
31: 
32: # Copy binary from builder
33: COPY --from=builder /app/target/release/matrix-bridge /app/matrix-bridge
34: 
35: # Create directories for persistent data
36: RUN mkdir -p /app/sessions_db /app/crypto_store && \
37:     chown -R claude:claude /app
38: 
39: # Switch to non-root user
40: USER claude
41: 
42: # Volumes for persistent data
43: VOLUME ["/app/sessions_db", "/app/crypto_store"]
44: 
45: # Run the bot
46: CMD ["/app/matrix-bridge"]
</file>

<file path=".github/workflows/release.yml">
  1: # ABOUTME: GitHub Actions release workflow for cross-platform binary builds and GitHub releases
  2: # ABOUTME: Builds Linux and macOS binaries on v* tags, generates changelog from commits, creates release
  3: name: Release
  4: on:
  5:   push:
  6:     tags:
  7:       - 'v*'
  8: jobs:
  9:   build:
 10:     name: Build ${{ matrix.platform }}
 11:     runs-on: ${{ matrix.os }}
 12:     strategy:
 13:       matrix:
 14:         include:
 15:           - os: ubuntu-latest
 16:             target: x86_64-unknown-linux-gnu
 17:             platform: Linux x86_64
 18:             artifact_name: matrix-bridge-linux-x86_64
 19:           - os: macos-latest
 20:             target: x86_64-apple-darwin
 21:             platform: macOS x86_64
 22:             artifact_name: matrix-bridge-macos-x86_64
 23:     steps:
 24:       - name: Checkout code
 25:         uses: actions/checkout@v4
 26:         with:
 27:           fetch-depth: 0
 28:       - name: Install Rust stable
 29:         uses: dtolnay/rust-toolchain@stable
 30:         with:
 31:           targets: ${{ matrix.target }}
 32:       - name: Cache cargo registry
 33:         uses: actions/cache@v4
 34:         with:
 35:           path: |
 36:             ~/.cargo/bin/
 37:             ~/.cargo/registry/index/
 38:             ~/.cargo/registry/cache/
 39:             ~/.cargo/git/db/
 40:             target/
 41:           key: rust-cache-${{ matrix.os }}-${{ hashFiles('**/Cargo.lock') }}
 42:           restore-keys: |
 43:             rust-cache-${{ matrix.os }}-
 44:       - name: Build release binary
 45:         run: cargo build --release --target ${{ matrix.target }}
 46:       - name: Strip binary (Linux)
 47:         if: matrix.os == 'ubuntu-latest'
 48:         run: strip target/${{ matrix.target }}/release/matrix-bridge
 49:       - name: Strip binary (macOS)
 50:         if: matrix.os == 'macos-latest'
 51:         run: strip target/${{ matrix.target }}/release/matrix-bridge
 52:       - name: Rename binary
 53:         run: |
 54:           cp target/${{ matrix.target }}/release/matrix-bridge ${{ matrix.artifact_name }}
 55:       - name: Upload artifact
 56:         uses: actions/upload-artifact@v4
 57:         with:
 58:           name: ${{ matrix.artifact_name }}
 59:           path: ${{ matrix.artifact_name }}
 60:           if-no-files-found: error
 61:   release:
 62:     name: Create Release
 63:     needs: build
 64:     runs-on: ubuntu-latest
 65:     permissions:
 66:       contents: write
 67:     steps:
 68:       - name: Checkout code
 69:         uses: actions/checkout@v4
 70:         with:
 71:           fetch-depth: 0
 72:       - name: Download Linux artifact
 73:         uses: actions/download-artifact@v4
 74:         with:
 75:           name: matrix-bridge-linux-x86_64
 76:           path: ./artifacts
 77:       - name: Download macOS artifact
 78:         uses: actions/download-artifact@v4
 79:         with:
 80:           name: matrix-bridge-macos-x86_64
 81:           path: ./artifacts
 82:       - name: Generate changelog
 83:         id: changelog
 84:         run: |
 85:           # Get previous tag
 86:           PREV_TAG=$(git tag --sort=-v:refname | grep -v "^${GITHUB_REF_NAME}$" | head -n 1)
 87:           if [ -z "$PREV_TAG" ]; then
 88:             echo "No previous tag found, using all commits"
 89:             COMMITS=$(git log --pretty=format:"- %s" $GITHUB_REF_NAME)
 90:           else
 91:             echo "Generating changelog from $PREV_TAG to $GITHUB_REF_NAME"
 92:             COMMITS=$(git log --pretty=format:"- %s" $PREV_TAG..$GITHUB_REF_NAME)
 93:           fi
 94:           # Group by conventional commit type
 95:           FEATURES=$(echo "$COMMITS" | grep "^- feat:" || true)
 96:           FIXES=$(echo "$COMMITS" | grep "^- fix:" || true)
 97:           DOCS=$(echo "$COMMITS" | grep "^- docs:" || true)
 98:           CHORES=$(echo "$COMMITS" | grep "^- chore:" || true)
 99:           # Build changelog
100:           CHANGELOG="## Changes in $GITHUB_REF_NAME"
101:           if [ -n "$FEATURES" ]; then
102:             CHANGELOG="$CHANGELOG\n\n### Features\n$FEATURES"
103:           fi
104:           if [ -n "$FIXES" ]; then
105:             CHANGELOG="$CHANGELOG\n\n### Bug Fixes\n$FIXES"
106:           fi
107:           if [ -n "$DOCS" ]; then
108:             CHANGELOG="$CHANGELOG\n\n### Documentation\n$DOCS"
109:           fi
110:           if [ -n "$CHORES" ]; then
111:             CHANGELOG="$CHANGELOG\n\n### Chores\n$CHORES"
112:           fi
113:           # Save to file and output
114:           echo -e "$CHANGELOG" > changelog.md
115:           echo "changelog<<EOF" >> $GITHUB_OUTPUT
116:           cat changelog.md >> $GITHUB_OUTPUT
117:           echo "EOF" >> $GITHUB_OUTPUT
118:       - name: Create GitHub Release
119:         uses: softprops/action-gh-release@v1
120:         with:
121:           body: ${{ steps.changelog.outputs.changelog }}
122:           files: |
123:             ./artifacts/matrix-bridge-linux-x86_64
124:             ./artifacts/matrix-bridge-macos-x86_64
125:           fail_on_unmatched_files: true
126:         env:
127:           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path=".github/dependabot.yml">
 1: version: 2
 2: updates:
 3:   # Keep Rust dependencies up to date
 4:   - package-ecosystem: "cargo"
 5:     directory: "/"
 6:     schedule:
 7:       interval: "weekly"
 8:     open-pull-requests-limit: 10
 9:   # Keep GitHub Actions up to date
10:   - package-ecosystem: "github-actions"
11:     directory: "/"
12:     schedule:
13:       interval: "weekly"
14:     open-pull-requests-limit: 5
</file>

<file path="docs/examples/matrix-bridge/.env.example">
 1: # Matrix Bridge Configuration
 2: # Copy this file to .env and fill in your values
 3: 
 4: # Matrix homeserver URL (required)
 5: MATRIX_HOMESERVER=https://matrix.example.com
 6: 
 7: # Matrix bot user ID (required)
 8: MATRIX_USER=@bot:example.com
 9: 
10: # Matrix room ID to restrict bot to single room (optional - if not set, listens in ALL rooms)
11: # MATRIX_ROOM_ID=!abc123:example.com
12: 
13: # Matrix password (required if MATRIX_ACCESS_TOKEN is not set)
14: MATRIX_PASSWORD=your_password_here
15: 
16: # Matrix access token (optional, alternative to password)
17: # MATRIX_ACCESS_TOKEN=syt_your_token_here
18: 
19: # Path to claude binary (optional, defaults to "claude")
20: # CLAUDE_BIN=/usr/local/bin/claude
21: 
22: # SDK URL for remote Claude Code server (optional)
23: # SDK_URL=http://localhost:8080
</file>

<file path="docs/examples/matrix-bridge/.gitignore">
 1: # Environment variables
 2: .env
 3: 
 4: # Python
 5: __pycache__/
 6: *.py[cod]
 7: *$py.class
 8: *.so
 9: .Python
10: .venv/
11: venv/
12: ENV/
13: 
14: # IDE
15: .vscode/
16: .idea/
17: *.swp
18: *.swo
19: 
20: # OS
21: .DS_Store
</file>

<file path="docs/examples/matrix-bridge/.python-version">
1: 3.10
</file>

<file path="docs/examples/matrix-bridge/main.py">
  1: #!/usr/bin/env python3
  2: """
  3: Matrix ‚Üî Claude Code bridge.
  4: Listens for messages starting with !claude and proxies them to the Claude CLI.
  5: """
  6: from __future__ import annotations
  7: import asyncio
  8: import json
  9: import os
 10: import sys
 11: import uuid
 12: from dataclasses import dataclass
 13: from typing import Dict, Optional
 14: from dotenv import load_dotenv
 15: from nio import (
 16:     AsyncClient,
 17:     LoginResponse,
 18:     RoomMessageText,
 19: )
 20: # Load environment variables from .env file
 21: load_dotenv()
 22: COMMAND_PREFIX = "!claude"
 23: CLAUDE_BIN = os.environ.get("CLAUDE_BIN", "claude")
 24: SDK_URL = os.environ.get("SDK_URL")
 25: @dataclass
 26: class SessionState:
 27:     session_id: str
 28:     started: bool = False
 29:     def cli_args(self) -> list[str]:
 30:         if self.started:
 31:             return ["--resume", self.session_id]
 32:         self.started = True
 33:         return ["--session-id", self.session_id]
 34:     def reset(self) -> None:
 35:         self.session_id = str(uuid.uuid4())
 36:         self.started = False
 37: sessions: Dict[str, SessionState] = {}
 38: def env_or_exit(name: str) -> str:
 39:     value = os.environ.get(name)
 40:     if not value:
 41:         print(f"Missing required environment variable: {name}", file=sys.stderr)
 42:         sys.exit(1)
 43:     return value
 44: async def run_claude(prompt: str, state: SessionState) -> str:
 45:     args = [CLAUDE_BIN, "--print", "--output-format", "json", *state.cli_args()]
 46:     if SDK_URL:
 47:         args += ["--sdk-url", SDK_URL]
 48:     args.append(prompt)
 49:     # Log the command being run (hide the full prompt for brevity)
 50:     args_display = args[:-1] + [f'"{prompt[:30]}..."']
 51:     print(f"  üíª Running: {' '.join(args_display)}")
 52:     proc = await asyncio.create_subprocess_exec(
 53:         *args,
 54:         stdout=asyncio.subprocess.PIPE,
 55:         stderr=asyncio.subprocess.PIPE,
 56:     )
 57:     stdout, stderr = await proc.communicate()
 58:     stdout_text = stdout.decode("utf-8", errors="ignore").strip()
 59:     stderr_text = stderr.decode("utf-8", errors="ignore").strip()
 60:     if proc.returncode != 0:
 61:         print(f"  ‚ö†Ô∏è Claude CLI failed with exit code {proc.returncode}")
 62:         raise RuntimeError(
 63:             f"Claude CLI exited with {proc.returncode}\n{stderr_text or stdout_text}"
 64:         )
 65:     if not stdout_text:
 66:         return "(no output)"
 67:     try:
 68:         payload = json.loads(stdout_text)
 69:         parts = [block.get("text", "") for block in payload.get("content", [])]
 70:         text = "\n".join(parts).strip()
 71:         return text or stdout_text
 72:     except json.JSONDecodeError:
 73:         return stdout_text
 74: async def handle_message(room, event, client: AsyncClient, allowed_room_id: Optional[str]):
 75:     # If a specific room_id is configured, only respond in that room
 76:     if allowed_room_id and room.room_id != allowed_room_id:
 77:         return
 78:     if not isinstance(event, RoomMessageText):
 79:         return
 80:     if event.sender == client.user:
 81:         return
 82:     body = event.body.strip()
 83:     if not body.lower().startswith(COMMAND_PREFIX):
 84:         return
 85:     current_room_id = room.room_id
 86:     print(f"üì® Received message in {current_room_id} from {event.sender}: {body}")
 87:     content = body[len(COMMAND_PREFIX) :].strip()
 88:     if not content:
 89:         await send_message(client, current_room_id, "Usage: !claude <prompt>")
 90:         return
 91:     session = sessions.setdefault(current_room_id, SessionState(str(uuid.uuid4())))
 92:     print(f"üîë Using session: {session.session_id[:8]}... (started: {session.started})")
 93:     if content in {"/reset", "/restart"}:
 94:         print(f"üîÑ Resetting session...")
 95:         session.reset()
 96:         sessions[current_room_id] = session
 97:         await send_message(
 98:             client, current_room_id, f"üîÑ Session reset (new id: {session.session_id})"
 99:         )
100:         return
101:     if content in {"/end", "/stop"}:
102:         print(f"‚úÇÔ∏è Ending session...")
103:         sessions.pop(current_room_id, None)
104:         await send_message(client, current_room_id, "‚úÇÔ∏è Session ended.")
105:         return
106:     print(f"ü§ñ Invoking Claude CLI with prompt: {content[:50]}...")
107:     await send_typing(client, current_room_id, timeout=30000)
108:     try:
109:         response = await run_claude(content, session)
110:         print(f"‚úÖ Claude responded ({len(response)} chars)")
111:     except Exception as exc:  # pylint: disable=broad-except
112:         print(f"‚ùå Claude error: {exc}")
113:         await send_message(client, current_room_id, f"‚ö†Ô∏è Claude error:\n{exc}")
114:         return
115:     finally:
116:         await send_typing(client, current_room_id, timeout=0)
117:     print(f"üì§ Sending response to Matrix...")
118:     await send_message(client, current_room_id, response)
119:     print(f"‚ú® Done!")
120: async def send_message(client: AsyncClient, room_id: str, text: str) -> None:
121:     await client.room_send(
122:         room_id,
123:         message_type="m.room.message",
124:         content={
125:             "msgtype": "m.text",
126:             "body": text,
127:         },
128:     )
129: async def send_typing(client: AsyncClient, room_id: str, timeout: int) -> None:
130:     try:
131:         await client.room_typing(room_id, bool(timeout), timeout=timeout)
132:     except Exception:
133:         pass
134: async def login_client(client: AsyncClient, password: Optional[str]) -> None:
135:     if client.access_token:
136:         print("üîë Using provided access token.")
137:         return
138:     if not password:
139:         print("‚ùå Password or access token required.", file=sys.stderr)
140:         sys.exit(1)
141:     print("üîê Logging in to Matrix...")
142:     resp = await client.login(password=password, device_name="claude-matrix-bridge")
143:     if isinstance(resp, LoginResponse):
144:         print(f"‚úÖ Logged in as {client.user_id}")
145:     else:
146:         print(f"‚ùå Login failed: {resp}", file=sys.stderr)
147:         sys.exit(1)
148: async def main() -> None:
149:     print("=" * 60)
150:     print("üåâ Matrix ‚Üî Claude Code Bridge")
151:     print("=" * 60)
152:     homeserver = env_or_exit("MATRIX_HOMESERVER")
153:     user_id = env_or_exit("MATRIX_USER")
154:     room_id = os.environ.get("MATRIX_ROOM_ID")  # Optional now!
155:     password = os.environ.get("MATRIX_PASSWORD")
156:     access_token = os.environ.get("MATRIX_ACCESS_TOKEN")
157:     print(f"üè† Homeserver: {homeserver}")
158:     print(f"üë§ Bot user: {user_id}")
159:     if room_id:
160:         print(f"üí¨ Restricted to room: {room_id}")
161:     else:
162:         print(f"üí¨ Listening in ALL rooms")
163:     print(f"ü§ñ Claude binary: {CLAUDE_BIN}")
164:     if SDK_URL:
165:         print(f"üîó SDK URL: {SDK_URL}")
166:     print()
167:     client = AsyncClient(homeserver, user_id)
168:     if access_token:
169:         client.access_token = access_token
170:         client.user_id = user_id
171:     await login_client(client, password)
172:     client.add_event_callback(
173:         lambda room, event: handle_message(room, event, client, room_id),
174:         RoomMessageText,
175:     )
176:     print()
177:     print("=" * 60)
178:     print(f"üëÇ Listening for '{COMMAND_PREFIX}' commands...")
179:     print("=" * 60)
180:     print()
181:     await client.sync_forever(timeout=30000, full_state=True)
182: if __name__ == "__main__":
183:     try:
184:         asyncio.run(main())
185:     except KeyboardInterrupt:
186:         print("\nGoodbye!")
</file>

<file path="docs/examples/matrix-bridge/pyproject.toml">
 1: [project]
 2: name = "matrix-bridge"
 3: version = "0.1.0"
 4: description = "Add your description here"
 5: readme = "README.md"
 6: requires-python = ">=3.10"
 7: dependencies = [
 8:     "matrix-nio>=0.24.0",
 9:     "python-dotenv>=1.2.1",
10: ]
</file>

<file path="docs/examples/matrix-bridge/README.md">
 1: # Matrix ‚ÜîÔ∏é Claude Code Bridge (Python)
 2: 
 3: This example shows how to connect a Matrix room to Claude Code by spawning the
 4: `claude` CLI for every inbound message. It uses[`matrix-nio`](https://github.com/poljar/matrix-nio)
 5: and mirrors the same CLI flags as the terminal demos, so you can optionally
 6: tunnel through `--sdk-url`.
 7: 
 8: ## Features
 9: 
10: - Listens to a single room and responds when a message starts with `!claude`
11:   (or when the bot is mentioned).
12: - Keeps a long-lived Claude session per Matrix room so follow-ups share context.
13: - Supports `/reset` and `/end` commands inside Matrix to drop the session.
14: - Pipes replies back to the room as Markdown/plain text.
15: 
16: ## Prerequisites
17: 
18: 1. Claude Code CLI must be installed and authenticated.
19: 2. Python 3.10+ (asyncio + `asyncio.create_subprocess_exec`).
20: 3. A Matrix account for the bot and a room ID that the bot can access.
21: 
22: Install dependencies:
23: 
24: ```bash
25: cd examples/matrix-bridge
26: uv sync
27: ```
28: 
29: ## Configuration
30: 
31: Copy `.env.example` to `.env` and fill in your Matrix credentials:
32: 
33: ```bash
34: cp .env.example .env
35: ```
36: 
37: Edit `.env` with your values:
38: 
39: | Variable | Required | Description |
40: |----------|----------|-------------|
41: | `MATRIX_HOMESERVER` | Yes | Base URL, e.g. `https://matrix.example.com` |
42: | `MATRIX_USER` | Yes | Matrix user ID (`@bot:example.com`) |
43: | `MATRIX_ROOM_ID` | No | **Optional** - Room ID to restrict bot to single room (e.g. `!abc123:example.com`). If not set, bot listens in ALL rooms. |
44: | `MATRIX_PASSWORD` | Yes* | Account password (*or use `MATRIX_ACCESS_TOKEN`) |
45: | `MATRIX_ACCESS_TOKEN` | No | Optional access token instead of password |
46: | `CLAUDE_BIN` | No | Optional path to the `claude` binary (defaults to `claude`) |
47: | `SDK_URL` | No | Optional `--sdk-url` forwarded to the CLI |
48: 
49: ## Usage
50: 
51: ```bash
52: cd examples/matrix-bridge
53: uv run python main.py
54: ```
55: 
56: In the Matrix room, use:
57: 
58: - `!claude <prompt>` to send a prompt.
59: - `!claude /reset` to discard the existing Claude session.
60: - `!claude /end` to drop the session without starting a new one.
61: 
62: You can customize the prefix by editing `COMMAND_PREFIX` inside the script.
63: 
64: ## Caveats
65: 
66: - This example is intentionally simple (no retries, no encryption, no state
67:   persistence). For production, add proper logging, health checks, and store
68:   session IDs in a database.
69: - The CLI runs on the same host as the bot. If you need remote execution, set
70:   `SDK_URL` to point at your Claude Code SDK server and forward any directory
71:   mounts as needed.
</file>

<file path="docs/examples/matrix-bridge/requirements.txt">
1: matrix-nio>=0.24.0
2: python-dotenv>=1.0.0
</file>

<file path="docs/examples/simple-tui/index.js">
  1: #!/usr/bin/env node
  2: /**
  3:  * Minimal terminal UI that proxies user input to the Claude CLI.
  4:  * It keeps a single session alive and repaints the chat log after each turn.
  5:  */
  6: const { spawn } = require("node:child_process");
  7: const readline = require("node:readline");
  8: const crypto = require("node:crypto");
  9: const os = require("node:os");
 10: const chalk = require("chalk");
 11: const CLAUDE_BIN = process.env.CLAUDE_BIN || "claude";
 12: const sdkUrl = process.env.SDK_URL;
 13: let sessionId =
 14:   process.env.SESSION_ID ||
 15:   crypto.randomUUID().replace(/-/g, ""); // keep it short for the UI
 16: let hasStarted = false;
 17: const history = [];
 18: const rl = readline.createInterface({
 19:   input: process.stdin,
 20:   output: process.stdout,
 21:   prompt: chalk.green("> "),
 22: });
 23: function banner() {
 24:   return [
 25:     chalk.cyan("Claude Code ‚Äì Simple TUI Demo"),
 26:     chalk.dim(
 27:       `session: ${sessionId} (set SESSION_ID to reuse, type /reset to start over)`
 28:     ),
 29:     chalk.dim("Type `/quit` to exit."),
 30:     "",
 31:   ].join(os.EOL);
 32: }
 33: function render() {
 34:   console.clear();
 35:   console.log(banner());
 36:   for (const entry of history) {
 37:     const prefix =
 38:       entry.role === "user" ? chalk.green("You ") : chalk.blue("Claude");
 39:     console.log(prefix + chalk.dim(":"));
 40:     console.log(entry.text + os.EOL);
 41:   }
 42:   rl.prompt();
 43: }
 44: async function runTurn(message) {
 45:   history.push({ role: "user", text: message });
 46:   render();
 47:   const args = [
 48:     "--print",
 49:     "--output-format",
 50:     "json",
 51:   ];
 52:   if (!hasStarted) {
 53:     args.push("--session-id", sessionId);
 54:     hasStarted = true;
 55:   } else {
 56:     args.push("--resume", sessionId);
 57:   }
 58:   if (sdkUrl) {
 59:     args.push("--sdk-url", sdkUrl);
 60:   }
 61:   const child = spawn(CLAUDE_BIN, [...args, message], {
 62:     stdio: ["ignore", "pipe", "pipe"],
 63:   });
 64:   let stdoutBuffer = "";
 65:   let stderrBuffer = "";
 66:   child.stdout.on("data", (chunk) => {
 67:     stdoutBuffer += chunk.toString("utf8");
 68:   });
 69:   child.stderr.on("data", (chunk) => {
 70:     stderrBuffer += chunk.toString("utf8");
 71:   });
 72:   child.on("close", (code) => {
 73:     if (code !== 0) {
 74:       history.push({
 75:         role: "error",
 76:         text:
 77:           chalk.red("Claude CLI exited with code ") +
 78:           code +
 79:           (stderrBuffer ? `\n${stderrBuffer}` : ""),
 80:       });
 81:       render();
 82:       return;
 83:     }
 84:     try {
 85:       const parsed = JSON.parse(stdoutBuffer.trim());
 86:       const text =
 87:         parsed?.content?.map((c) => c.text || "").join("\n").trim() ||
 88:         stdoutBuffer.trim();
 89:       history.push({ role: "assistant", text });
 90:     } catch (err) {
 91:       history.push({
 92:         role: "error",
 93:         text:
 94:           chalk.red("Failed to parse CLI output: ") +
 95:           err.message +
 96:           "\n" +
 97:           stdoutBuffer,
 98:       });
 99:     }
100:     render();
101:   });
102: }
103: function resetSession() {
104:   sessionId = crypto.randomUUID().replace(/-/g, "");
105:   hasStarted = false;
106:   history.push({
107:     role: "system",
108:     text: chalk.yellow(`Started new session: ${sessionId}`),
109:   });
110:   render();
111: }
112: render();
113: rl.on("line", (line) => {
114:   const trimmed = line.trim();
115:   if (!trimmed) {
116:     render();
117:     return;
118:   }
119:   if (trimmed === "/quit") {
120:     rl.close();
121:     return;
122:   }
123:   if (trimmed === "/reset") {
124:     resetSession();
125:     return;
126:   }
127:   runTurn(trimmed);
128: });
129: rl.on("SIGINT", () => {
130:   rl.close();
131: });
132: rl.on("close", () => {
133:   console.log(chalk.dim("\nGoodbye!"));
134:   process.exit(0);
135: });
</file>

<file path="docs/examples/simple-tui/package.json">
 1: {
 2:   "name": "claude-simple-tui",
 3:   "version": "0.1.0",
 4:   "description": "Minimal terminal UI that proxies to the Claude Code CLI",
 5:   "main": "index.js",
 6:   "type": "commonjs",
 7:   "scripts": {
 8:     "start": "node index.js"
 9:   },
10:   "dependencies": {
11:     "chalk": "^5.3.0"
12:   }
13: }
</file>

<file path="docs/examples/simple-tui/README.md">
 1: # Simple Claude Code TUI Demo
 2: 
 3: This example shows how to build a tiny terminal UI that shells out to the `claude`
 4: CLI in `--print` mode. It keeps a session alive across turns, renders an
 5: in-place chat log, and demonstrates how to pass through extra flags such as
 6: `--sdk-url` when you want the CLI to act as a thin WebSocket client.
 7: 
 8: ## Prerequisites
 9: 
10: 1. Claude Code CLI must already be authenticated on this machine.
11: 2. Node 18+ (or any Node release that supports `crypto.randomUUID`).
12: 3. Optional: set `SDK_URL` to point at a remote Claude Code SDK server.
13: 
14: ## Usage
15: 
16: ```bash
17: # install deps
18: cd examples/simple-tui
19: npm install
20: 
21: # run the demo
22: npm start
23: 
24: # specify a remote SDK server (forwarded via --sdk-url)
25: SDK_URL=ws://localhost:8080 npm start
26: 
27: # choose a fixed session id so you can reconnect later
28: SESSION_ID=your-session-guid npm start
29: ```
30: 
31: Controls:
32: 
33: - Type a prompt and press Enter to send it.
34: - `/reset` drops the existing conversation and starts a new session.
35: - `/quit` or Ctrl+C exits without touching the underlying session.
36: 
37: ### Python alternative
38: 
39: Prefer Python? Run:
40: 
41: ```bash
42: cd examples/simple-tui
43: python3 tui.py
44: 
45: # With remote SDK server
46: SDK_URL=ws://localhost:8080 python3 tui.py
47: ```
48: 
49: Both variants share the same environment knobs (`SESSION_ID`, `SDK_URL`, `CLAUDE_BIN`)
50: so you can switch between them freely.
51: 
52: Under the hood this script spawns the CLI with:
53: 
54: ```
55: claude --print --input-format text --output-format json \
56:        --session-id/--resume ... [--sdk-url ...]
57: ```
58: 
59: and pipes user messages through stdin so you do not have to worry about shell
60: escaping. Because it uses the CLI exactly how a Matrix bridge or other bot
61: integration would, you can use it as a reference implementation for wiring
62: Claude Code into any other text-based frontend.***
</file>

<file path="docs/examples/simple-tui/tui.py">
  1: #!/usr/bin/env python3
  2: """Minimal Python TUI that proxies to the Claude CLI."""
  3: from __future__ import annotations
  4: import json
  5: import os
  6: import subprocess
  7: import sys
  8: import uuid
  9: CLAUDE_BIN = os.environ.get("CLAUDE_BIN", "claude")
 10: SDK_URL = os.environ.get("SDK_URL")
 11: def clear_screen() -> None:
 12:     os.system("cls" if os.name == "nt" else "clear")
 13: class Session:
 14:     def __init__(self) -> None:
 15:         self.session_id = self._initial_session_id()
 16:         self.started = False
 17:         self.history: list[tuple[str, str]] = []
 18:     def reset(self) -> None:
 19:         self.session_id = str(uuid.uuid4())
 20:         self.started = False
 21:         self.history.append(("system", f"Started new session: {self.session_id}"))
 22:     def render(self) -> None:
 23:         clear_screen()
 24:         print("Claude Code ‚Äì Simple Python TUI\n")
 25:         print(f"Session: {self.session_id}")
 26:         if SDK_URL:
 27:             print(f"SDK URL: {SDK_URL}")
 28:         print("Commands: /reset, /quit\n")
 29:         for role, text in self.history:
 30:             prefix = {"user": "You", "assistant": "Claude"}.get(role, role)
 31:             print(f"{prefix}:")
 32:             print(text.strip(), end="\n\n")
 33:     def run_turn(self, message: str) -> None:
 34:         self.history.append(("user", message))
 35:         args = [
 36:             CLAUDE_BIN,
 37:             "--print",
 38:             "--output-format",
 39:             "json",
 40:         ]
 41:         if self.started:
 42:             args.extend(["--resume", self.session_id])
 43:         else:
 44:             args.extend(["--session-id", self.session_id])
 45:             self.started = True
 46:         if SDK_URL:
 47:             args.extend(["--sdk-url", SDK_URL])
 48:         proc = subprocess.Popen(
 49:             args + [message],
 50:             stdout=subprocess.PIPE,
 51:             stderr=subprocess.PIPE,
 52:             text=True,
 53:         )
 54:         stdout, stderr = proc.communicate()
 55:         if proc.returncode != 0:
 56:             self.history.append(
 57:                 (
 58:                     "error",
 59:                     f"Claude CLI exited with code {proc.returncode}:\n{stderr.strip()}",
 60:                 )
 61:             )
 62:             return
 63:         try:
 64:             payload = json.loads(stdout.strip())
 65:             text = "\n".join(
 66:                 block.get("text", "") for block in payload.get("content", [])
 67:             ).strip()
 68:             text = text or stdout.strip()
 69:         except json.JSONDecodeError:
 70:             text = f"[parse error]\n{stdout.strip()}"
 71:         self.history.append(("assistant", text))
 72:     def _initial_session_id(self) -> str:
 73:         existing = os.environ.get("SESSION_ID")
 74:         if existing:
 75:             try:
 76:                 return str(uuid.UUID(existing))
 77:             except ValueError:
 78:                 print(
 79:                     "Warning: SESSION_ID was not a valid UUID; generating a new one.",
 80:                     file=sys.stderr,
 81:                 )
 82:         return str(uuid.uuid4())
 83: def main() -> None:
 84:     session = Session()
 85:     session.render()
 86:     try:
 87:         while True:
 88:             try:
 89:                 line = input("> ").strip()
 90:             except EOFError:
 91:                 break
 92:             if not line:
 93:                 session.render()
 94:                 continue
 95:             if line == "/quit":
 96:                 break
 97:             if line == "/reset":
 98:                 session.reset()
 99:                 session.render()
100:                 continue
101:             session.run_turn(line)
102:             session.render()
103:     except KeyboardInterrupt:
104:         pass
105:     finally:
106:         print("\nGoodbye!")
107: if __name__ == "__main__":
108:     main()
</file>

<file path="docs/plans/2025-12-02-matrix-claude-bridge-design.md">
  1: # Matrix-Claude Bridge Design
  2: 
  3: **Date:** 2025-12-02
  4: **Status:** Approved
  5: **Language:** Rust
  6: 
  7: ## Overview
  8: 
  9: This Rust Matrix bot bridges messages from one encrypted room to Claude Code's CLI and maintains conversation context across sessions.
 10: 
 11: ## Core Requirements
 12: 
 13: - Listen to one specific Matrix room
 14: - Respond only to whitelisted users (silently ignore unauthorized users)
 15: - Respond to every message from authorized users (no command prefix required)
 16: - Enable E2E encryption
 17: - Spawn `claude` CLI for each message
 18: - Persist session state per room
 19: - Log structured events
 20: 
 21: ## Architecture
 22: 
 23: ### Dependencies
 24: 
 25: - **`matrix-sdk`** (with `e2e-encryption` feature) - Matrix protocol + E2E crypto
 26: - **`tokio`** - Async runtime
 27: - **`tracing`** + **`tracing-subscriber`** - Structured logging
 28: - **`dotenvy`** - Environment variable loading
 29: - **`serde`** + **`serde_json`** - Parse Claude CLI JSON output
 30: - **`sled`** - Embedded database for session persistence
 31: 
 32: ### Main Loop
 33: 
 34: 1. Load configuration from `.env`
 35: 2. Log in to Matrix (password or access token)
 36: 3. Initialize E2E encryption with `SqliteCryptoStore`
 37: 4. Join configured room
 38: 5. Listen to sync stream
 39: 6. For each message:
 40:    - Verify room matches `MATRIX_ROOM_ID`
 41:    - Verify sender appears in `ALLOWED_USERS` whitelist
 42:    - Skip bot's own messages
 43:    - Load session from sled (create new UUID if missing)
 44:    - Set typing indicator
 45:    - Spawn `claude` CLI with session args
 46:    - Parse JSON response
 47:    - Send response to Matrix
 48:    - Save session state
 49: 
 50: ## Configuration
 51: 
 52: Environment variables (Rust-idiomatic naming):
 53: 
 54: ### Matrix Settings
 55: - `MATRIX_HOME_SERVER` - Homeserver URL (required)
 56: - `MATRIX_USER_ID` - Bot's user ID (required)
 57: - `MATRIX_ROOM_ID` - Target room ID (required)
 58: - `MATRIX_PASSWORD` - Login password (optional if using token)
 59: - `MATRIX_ACCESS_TOKEN` - Alternative to password
 60: - `MATRIX_DEVICE_NAME` - Device name (default: "claude-matrix-bridge")
 61: 
 62: ### Access Control
 63: - `ALLOWED_USERS` - Comma-separated authorized user IDs (required)
 64: 
 65: ### Claude Settings
 66: - `CLAUDE_BINARY_PATH` - Path to `claude` CLI (default: "claude")
 67: - `CLAUDE_SDK_URL` - Optional SDK server URL
 68: 
 69: ### Logging
 70: - `RUST_LOG` - Log filter (e.g., `info`, `debug`)
 71: 
 72: ## Message Handling Flow
 73: 
 74: 1. **Room filter** - Ignore messages from other rooms
 75: 2. **Authorization check** - Verify sender in `ALLOWED_USERS` HashSet
 76: 3. **Self-message filter** - Ignore bot's own messages
 77: 4. **Session lookup** - Load from sled or create new UUID
 78: 5. **Typing indicator** - Signal bot is working
 79: 6. **Spawn Claude CLI**:
 80:    - First message: `--session-id <uuid>`
 81:    - Follow-ups: `--resume <uuid>`
 82: 7. **Parse response** - Extract text from JSON content blocks
 83: 8. **Send to Matrix** - Post as `m.room.message`
 84: 9. **Clear typing** - Stop typing indicator
 85: 10. **Update session** - Mark as started, save to sled
 86: 
 87: ## E2E Encryption
 88: 
 89: - Enable `e2e-encryption` feature in Cargo.toml
 90: - Create `SqliteCryptoStore` at `./crypto_store/`
 91: - First run requires manual device verification (Element, etc.)
 92: - Matrix SDK handles encryption/decryption automatically
 93: - Crypto state persists across restarts
 94: - Log decryption failures (usually means unverified device)
 95: 
 96: **Recovery:** Delete `./crypto_store/` and re-verify device if corrupted
 97: 
 98: ## Error Handling
 99: 
100: ### Error Types
101: 
102: 1. **Configuration errors** - Missing/invalid env vars ‚Üí log and exit
103: 2. **Matrix login failures** - Bad credentials ‚Üí log and exit
104: 3. **Matrix sync failures** - Network issues ‚Üí log, retry with exponential backoff (max 60s)
105: 4. **E2E decryption failures** - Missing keys ‚Üí log warning, send error to room
106: 5. **Claude CLI failures** - Non-zero exit ‚Üí log stderr, send error to room
107: 6. **Message send failures** - Can't post response ‚Üí log only (can't notify user)
108: 
109: ### User-Facing Error Messages
110: 
111: - Decryption failure: "‚ö†Ô∏è Cannot decrypt message (verify device first)"
112: - Claude error: "‚ö†Ô∏è Claude error: <brief description>"
113: 
114: ### Logging Strategy
115: 
116: **Spans for request tracing:**
117: ```rust
118: tracing::info_span!("handle_message", room_id = %room.room_id(), sender = %event.sender())
119: ```
120: 
121: **Log levels:**
122: - `ERROR` - Fatal startup issues
123: - `WARN` - Recoverable issues (decryption, Claude errors)
124: - `INFO` - Key events (messages, responses, login)
125: - `DEBUG` - Detailed flow (sessions, CLI args, parsing)
126: - `TRACE` - Matrix SDK internals
127: 
128: ## Project Structure
129: 
130: ```
131: matrix-productivity/
132: ‚îú‚îÄ‚îÄ Cargo.toml
133: ‚îú‚îÄ‚îÄ .env.example
134: ‚îú‚îÄ‚îÄ .gitignore
135: ‚îú‚îÄ‚îÄ src/
136: ‚îÇ   ‚îú‚îÄ‚îÄ main.rs               # Entry point, setup
137: ‚îÇ   ‚îú‚îÄ‚îÄ config.rs             # Env parsing, validation
138: ‚îÇ   ‚îú‚îÄ‚îÄ matrix_client.rs      # Login, sync loop
139: ‚îÇ   ‚îú‚îÄ‚îÄ message_handler.rs    # Auth checks, processing
140: ‚îÇ   ‚îú‚îÄ‚îÄ claude.rs             # CLI spawning, JSON parsing
141: ‚îÇ   ‚îî‚îÄ‚îÄ session.rs            # Session state, sled DB
142: ‚îú‚îÄ‚îÄ crypto_store/             # E2E crypto state (gitignored)
143: ‚îú‚îÄ‚îÄ sessions_db/              # Session persistence (gitignored)
144: ‚îî‚îÄ‚îÄ docs/
145:     ‚îî‚îÄ‚îÄ examples/
146:         ‚îî‚îÄ‚îÄ matrix-bridge/    # Python reference
147: ```
148: 
149: ## Testing Strategy
150: 
151: ### Unit Tests
152: - `config.rs` - Env parsing, validation, error cases
153: - `claude.rs` - JSON parsing with various outputs
154: - `session.rs` - CRUD operations, persistence
155: 
156: ### Integration Tests (Manual)
157: - Set up test Matrix room with E2E
158: - Add test user to whitelist
159: - Verify Claude responses appear
160: - Verify unauthorized users get silently ignored
161: - Verify session persistence across restarts
162: 
163: **Real dependencies:** Tests use actual sled, Matrix SDK, and Claude CLI
164: 
165: ## Success Criteria
166: 
167: - Bot successfully logs in and joins room
168: - E2E encryption works (can decrypt/send encrypted messages)
169: - Only whitelisted users get responses
170: - Unauthorized users are silently ignored
171: - Claude sessions persist across messages
172: - Bot restarts recover session state from disk
173: - Errors are logged and reported to users appropriately
174: - All structured logs contain relevant context
</file>

<file path="docs/plans/2025-12-02-matrix-claude-bridge-implementation.md">
   1: # Matrix-Claude Bridge Implementation Plan
   2: 
   3: > **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.
   4: 
   5: **Goal:** Build a Rust Matrix bot that bridges one encrypted room to Claude Code CLI with persistent sessions and whitelist-based access control.
   6: 
   7: **Architecture:** Async Rust binary using matrix-sdk for E2E encrypted Matrix messaging, sled for session persistence, and tokio::process to spawn claude CLI. Each message triggers Claude invocation with session context, responses return to Matrix.
   8: 
   9: **Tech Stack:** Rust, tokio, matrix-sdk (e2e-encryption), sled, tracing, dotenvy, serde
  10: 
  11: ---
  12: 
  13: ## Task 1: Project Initialization
  14: 
  15: **Files:**
  16: - Create: `Cargo.toml`
  17: - Create: `.env.example`
  18: - Create: `.gitignore`
  19: - Create: `README.md`
  20: 
  21: **Step 1: Create Cargo.toml with dependencies**
  22: 
  23: Create `Cargo.toml`:
  24: 
  25: ```toml
  26: [package]
  27: name = "matrix-bridge"
  28: version = "0.1.0"
  29: edition = "2021"
  30: 
  31: [dependencies]
  32: tokio = { version = "1", features = ["full"] }
  33: matrix-sdk = { version = "0.7", features = ["e2e-encryption"] }
  34: sled = "0.34"
  35: tracing = "0.1"
  36: tracing-subscriber = { version = "0.3", features = ["env-filter"] }
  37: dotenvy = "0.15"
  38: serde = { version = "1.0", features = ["derive"] }
  39: serde_json = "1.0"
  40: anyhow = "1.0"
  41: ```
  42: 
  43: **Step 2: Create .env.example**
  44: 
  45: Create `.env.example`:
  46: 
  47: ```bash
  48: # Matrix Settings
  49: MATRIX_HOME_SERVER=https://matrix.example.com
  50: MATRIX_USER_ID=@bot:example.com
  51: MATRIX_ROOM_ID=!abc123:example.com
  52: MATRIX_PASSWORD=your_password_here
  53: # MATRIX_ACCESS_TOKEN=optional_token_instead_of_password
  54: MATRIX_DEVICE_NAME=claude-matrix-bridge
  55: 
  56: # Access Control
  57: ALLOWED_USERS=@you:example.com,@friend:example.com
  58: 
  59: # Claude Settings
  60: CLAUDE_BINARY_PATH=claude
  61: # CLAUDE_SDK_URL=http://localhost:8080
  62: 
  63: # Logging
  64: RUST_LOG=info
  65: ```
  66: 
  67: **Step 3: Create .gitignore**
  68: 
  69: Create `.gitignore`:
  70: 
  71: ```
  72: /target
  73: .env
  74: crypto_store/
  75: sessions_db/
  76: *.swp
  77: *.swo
  78: *~
  79: .DS_Store
  80: ```
  81: 
  82: **Step 4: Create README.md**
  83: 
  84: Create `README.md`:
  85: 
  86: ```markdown
  87: # Matrix-Claude Bridge
  88: 
  89: Rust bot that bridges Matrix room messages to Claude Code CLI.
  90: 
  91: ## Setup
  92: 
  93: 1. Copy `.env.example` to `.env` and configure
  94: 2. Build: `cargo build --release`
  95: 3. Run: `cargo run --release`
  96: 
  97: ## Configuration
  98: 
  99: See `.env.example` for all options.
 100: 
 101: ## First Run
 102: 
 103: The bot creates a new Matrix device on first login. You must verify this device from another Matrix client (Element, etc.) using emoji verification or cross-signing.
 104: ```
 105: 
 106: **Step 5: Verify project builds**
 107: 
 108: Run:
 109: ```bash
 110: cargo check
 111: ```
 112: 
 113: Expected: Project compiles without errors
 114: 
 115: **Step 6: Commit project scaffolding**
 116: 
 117: ```bash
 118: git add Cargo.toml .env.example .gitignore README.md
 119: git commit -m "chore: initialize rust project with dependencies"
 120: ```
 121: 
 122: ---
 123: 
 124: ## Task 2: Config Module (TDD)
 125: 
 126: **Files:**
 127: - Create: `src/config.rs`
 128: - Create: `tests/config_tests.rs`
 129: 
 130: **Step 1: Write failing test for config loading**
 131: 
 132: Create `tests/config_tests.rs`:
 133: 
 134: ```rust
 135: use std::collections::HashSet;
 136: 
 137: #[test]
 138: fn test_config_loads_from_env() {
 139:     std::env::set_var("MATRIX_HOME_SERVER", "https://test.com");
 140:     std::env::set_var("MATRIX_USER_ID", "@bot:test.com");
 141:     std::env::set_var("MATRIX_ROOM_ID", "!room:test.com");
 142:     std::env::set_var("MATRIX_PASSWORD", "secret");
 143:     std::env::set_var("ALLOWED_USERS", "@user1:test.com,@user2:test.com");
 144: 
 145:     let config = matrix_bridge::config::Config::from_env().unwrap();
 146: 
 147:     assert_eq!(config.matrix_home_server, "https://test.com");
 148:     assert_eq!(config.matrix_user_id, "@bot:test.com");
 149:     assert_eq!(config.matrix_room_id, "!room:test.com");
 150:     assert_eq!(config.matrix_password, Some("secret".to_string()));
 151:     assert_eq!(config.allowed_users.len(), 2);
 152:     assert!(config.allowed_users.contains("@user1:test.com"));
 153: }
 154: 
 155: #[test]
 156: fn test_config_fails_on_missing_required_field() {
 157:     std::env::remove_var("MATRIX_HOME_SERVER");
 158:     std::env::remove_var("MATRIX_USER_ID");
 159: 
 160:     let result = matrix_bridge::config::Config::from_env();
 161: 
 162:     assert!(result.is_err());
 163: }
 164: ```
 165: 
 166: **Step 2: Run test to verify it fails**
 167: 
 168: Run:
 169: ```bash
 170: cargo test config_loads_from_env
 171: ```
 172: 
 173: Expected: FAIL with "no `config` module"
 174: 
 175: **Step 3: Write minimal config implementation**
 176: 
 177: Create `src/config.rs`:
 178: 
 179: ```rust
 180: use anyhow::{Context, Result};
 181: use std::collections::HashSet;
 182: 
 183: #[derive(Debug, Clone)]
 184: pub struct Config {
 185:     pub matrix_home_server: String,
 186:     pub matrix_user_id: String,
 187:     pub matrix_room_id: String,
 188:     pub matrix_password: Option<String>,
 189:     pub matrix_access_token: Option<String>,
 190:     pub matrix_device_name: String,
 191:     pub allowed_users: HashSet<String>,
 192:     pub claude_binary_path: String,
 193:     pub claude_sdk_url: Option<String>,
 194: }
 195: 
 196: impl Config {
 197:     pub fn from_env() -> Result<Self> {
 198:         let matrix_home_server = std::env::var("MATRIX_HOME_SERVER")
 199:             .context("MATRIX_HOME_SERVER is required")?;
 200:         let matrix_user_id = std::env::var("MATRIX_USER_ID")
 201:             .context("MATRIX_USER_ID is required")?;
 202:         let matrix_room_id = std::env::var("MATRIX_ROOM_ID")
 203:             .context("MATRIX_ROOM_ID is required")?;
 204:         let matrix_password = std::env::var("MATRIX_PASSWORD").ok();
 205:         let matrix_access_token = std::env::var("MATRIX_ACCESS_TOKEN").ok();
 206:         let matrix_device_name = std::env::var("MATRIX_DEVICE_NAME")
 207:             .unwrap_or_else(|_| "claude-matrix-bridge".to_string());
 208: 
 209:         let allowed_users_str = std::env::var("ALLOWED_USERS")
 210:             .context("ALLOWED_USERS is required")?;
 211:         let allowed_users: HashSet<String> = allowed_users_str
 212:             .split(',')
 213:             .map(|s| s.trim().to_string())
 214:             .filter(|s| !s.is_empty())
 215:             .collect();
 216: 
 217:         let claude_binary_path = std::env::var("CLAUDE_BINARY_PATH")
 218:             .unwrap_or_else(|_| "claude".to_string());
 219:         let claude_sdk_url = std::env::var("CLAUDE_SDK_URL").ok();
 220: 
 221:         Ok(Config {
 222:             matrix_home_server,
 223:             matrix_user_id,
 224:             matrix_room_id,
 225:             matrix_password,
 226:             matrix_access_token,
 227:             matrix_device_name,
 228:             allowed_users,
 229:             claude_binary_path,
 230:             claude_sdk_url,
 231:         })
 232:     }
 233: }
 234: ```
 235: 
 236: Create `src/lib.rs`:
 237: 
 238: ```rust
 239: pub mod config;
 240: ```
 241: 
 242: **Step 4: Run test to verify it passes**
 243: 
 244: Run:
 245: ```bash
 246: cargo test config_loads_from_env
 247: ```
 248: 
 249: Expected: PASS (both tests)
 250: 
 251: **Step 5: Commit config module**
 252: 
 253: ```bash
 254: git add src/lib.rs src/config.rs tests/config_tests.rs
 255: git commit -m "feat(config): add environment variable parsing with validation"
 256: ```
 257: 
 258: ---
 259: 
 260: ## Task 3: Session Module (TDD)
 261: 
 262: **Files:**
 263: - Create: `src/session.rs`
 264: - Create: `tests/session_tests.rs`
 265: 
 266: **Step 1: Write failing test for session persistence**
 267: 
 268: Create `tests/session_tests.rs`:
 269: 
 270: ```rust
 271: use std::path::PathBuf;
 272: 
 273: #[test]
 274: fn test_session_create_and_load() {
 275:     let temp_dir = std::env::temp_dir().join("matrix-bridge-test-sessions");
 276:     let _ = std::fs::remove_dir_all(&temp_dir);
 277: 
 278:     let store = matrix_bridge::session::SessionStore::new(&temp_dir).unwrap();
 279:     let room_id = "!test:example.com";
 280: 
 281:     // First load creates new session
 282:     let session1 = store.get_or_create(room_id).unwrap();
 283:     assert!(!session1.started);
 284: 
 285:     // Mark as started and save
 286:     store.mark_started(room_id).unwrap();
 287: 
 288:     // Second load returns same session, marked as started
 289:     let session2 = store.get_or_create(room_id).unwrap();
 290:     assert_eq!(session1.session_id, session2.session_id);
 291:     assert!(session2.started);
 292: 
 293:     // Cleanup
 294:     std::fs::remove_dir_all(&temp_dir).unwrap();
 295: }
 296: 
 297: #[test]
 298: fn test_session_cli_args_first_message() {
 299:     let session = matrix_bridge::session::Session {
 300:         session_id: "test-uuid".to_string(),
 301:         started: false,
 302:     };
 303: 
 304:     let args = session.cli_args();
 305: 
 306:     assert_eq!(args, vec!["--session-id", "test-uuid"]);
 307: }
 308: 
 309: #[test]
 310: fn test_session_cli_args_continuation() {
 311:     let session = matrix_bridge::session::Session {
 312:         session_id: "test-uuid".to_string(),
 313:         started: true,
 314:     };
 315: 
 316:     let args = session.cli_args();
 317: 
 318:     assert_eq!(args, vec!["--resume", "test-uuid"]);
 319: }
 320: ```
 321: 
 322: **Step 2: Run test to verify it fails**
 323: 
 324: Run:
 325: ```bash
 326: cargo test session_create_and_load
 327: ```
 328: 
 329: Expected: FAIL with "no `session` module"
 330: 
 331: **Step 3: Write minimal session implementation**
 332: 
 333: Create `src/session.rs`:
 334: 
 335: ```rust
 336: use anyhow::Result;
 337: use serde::{Deserialize, Serialize};
 338: use std::path::Path;
 339: 
 340: #[derive(Debug, Clone, Serialize, Deserialize)]
 341: pub struct Session {
 342:     pub session_id: String,
 343:     pub started: bool,
 344: }
 345: 
 346: impl Session {
 347:     pub fn cli_args(&self) -> Vec<&str> {
 348:         if self.started {
 349:             vec!["--resume", &self.session_id]
 350:         } else {
 351:             vec!["--session-id", &self.session_id]
 352:         }
 353:     }
 354: }
 355: 
 356: pub struct SessionStore {
 357:     db: sled::Db,
 358: }
 359: 
 360: impl SessionStore {
 361:     pub fn new<P: AsRef<Path>>(path: P) -> Result<Self> {
 362:         let db = sled::open(path)?;
 363:         Ok(SessionStore { db })
 364:     }
 365: 
 366:     pub fn get_or_create(&self, room_id: &str) -> Result<Session> {
 367:         if let Some(data) = self.db.get(room_id)? {
 368:             let session: Session = serde_json::from_slice(&data)?;
 369:             Ok(session)
 370:         } else {
 371:             let session = Session {
 372:                 session_id: uuid::Uuid::new_v4().to_string(),
 373:                 started: false,
 374:             };
 375:             self.save(room_id, &session)?;
 376:             Ok(session)
 377:         }
 378:     }
 379: 
 380:     pub fn mark_started(&self, room_id: &str) -> Result<()> {
 381:         let mut session = self.get_or_create(room_id)?;
 382:         session.started = true;
 383:         self.save(room_id, &session)?;
 384:         Ok(())
 385:     }
 386: 
 387:     fn save(&self, room_id: &str, session: &Session) -> Result<()> {
 388:         let data = serde_json::to_vec(session)?;
 389:         self.db.insert(room_id, data)?;
 390:         Ok(())
 391:     }
 392: }
 393: ```
 394: 
 395: Update `Cargo.toml` to add uuid dependency:
 396: 
 397: ```toml
 398: uuid = { version = "1.6", features = ["v4"] }
 399: ```
 400: 
 401: Update `src/lib.rs`:
 402: 
 403: ```rust
 404: pub mod config;
 405: pub mod session;
 406: ```
 407: 
 408: **Step 4: Run test to verify it passes**
 409: 
 410: Run:
 411: ```bash
 412: cargo test session_
 413: ```
 414: 
 415: Expected: PASS (all 3 tests)
 416: 
 417: **Step 5: Commit session module**
 418: 
 419: ```bash
 420: git add src/lib.rs src/session.rs tests/session_tests.rs Cargo.toml
 421: git commit -m "feat(session): add persistent session storage with sled"
 422: ```
 423: 
 424: ---
 425: 
 426: ## Task 4: Claude Module (TDD)
 427: 
 428: **Files:**
 429: - Create: `src/claude.rs`
 430: - Create: `tests/claude_tests.rs`
 431: 
 432: **Step 1: Write failing test for JSON parsing**
 433: 
 434: Create `tests/claude_tests.rs`:
 435: 
 436: ```rust
 437: #[test]
 438: fn test_parse_claude_response_success() {
 439:     let json = r#"{
 440:         "content": [
 441:             {"type": "text", "text": "Hello, "},
 442:             {"type": "text", "text": "world!"}
 443:         ]
 444:     }"#;
 445: 
 446:     let result = matrix_bridge::claude::parse_response(json).unwrap();
 447: 
 448:     assert_eq!(result, "Hello, world!");
 449: }
 450: 
 451: #[test]
 452: fn test_parse_claude_response_empty() {
 453:     let json = r#"{"content": []}"#;
 454: 
 455:     let result = matrix_bridge::claude::parse_response(json).unwrap();
 456: 
 457:     assert_eq!(result, "");
 458: }
 459: 
 460: #[test]
 461: fn test_parse_claude_response_malformed() {
 462:     let json = "not valid json";
 463: 
 464:     let result = matrix_bridge::claude::parse_response(json);
 465: 
 466:     assert!(result.is_err());
 467: }
 468: ```
 469: 
 470: **Step 2: Run test to verify it fails**
 471: 
 472: Run:
 473: ```bash
 474: cargo test claude_
 475: ```
 476: 
 477: Expected: FAIL with "no `claude` module"
 478: 
 479: **Step 3: Write minimal claude implementation**
 480: 
 481: Create `src/claude.rs`:
 482: 
 483: ```rust
 484: use anyhow::{Context, Result};
 485: use serde::Deserialize;
 486: use tokio::process::Command;
 487: 
 488: #[derive(Debug, Deserialize)]
 489: struct ClaudeResponse {
 490:     content: Vec<ContentBlock>,
 491: }
 492: 
 493: #[derive(Debug, Deserialize)]
 494: struct ContentBlock {
 495:     #[serde(rename = "type")]
 496:     block_type: String,
 497:     text: Option<String>,
 498: }
 499: 
 500: pub fn parse_response(json: &str) -> Result<String> {
 501:     let response: ClaudeResponse = serde_json::from_str(json)
 502:         .context("Failed to parse Claude JSON response")?;
 503: 
 504:     let text = response
 505:         .content
 506:         .iter()
 507:         .filter_map(|block| block.text.as_deref())
 508:         .collect::<Vec<_>>()
 509:         .join("");
 510: 
 511:     Ok(text)
 512: }
 513: 
 514: pub async fn invoke_claude(
 515:     binary_path: &str,
 516:     sdk_url: Option<&str>,
 517:     session_args: Vec<&str>,
 518:     prompt: &str,
 519: ) -> Result<String> {
 520:     let mut args = vec!["--print", "--output-format", "json"];
 521:     args.extend(session_args);
 522: 
 523:     if let Some(url) = sdk_url {
 524:         args.extend(["--sdk-url", url]);
 525:     }
 526: 
 527:     args.push(prompt);
 528: 
 529:     tracing::debug!(?args, "Spawning Claude CLI");
 530: 
 531:     let output = Command::new(binary_path)
 532:         .args(&args)
 533:         .output()
 534:         .await
 535:         .context("Failed to spawn claude CLI")?;
 536: 
 537:     if !output.status.success() {
 538:         let stderr = String::from_utf8_lossy(&output.stderr);
 539:         anyhow::bail!("Claude CLI failed with exit code {:?}: {}", output.status.code(), stderr);
 540:     }
 541: 
 542:     let stdout = String::from_utf8(output.stdout)
 543:         .context("Claude output is not valid UTF-8")?;
 544: 
 545:     parse_response(&stdout)
 546: }
 547: ```
 548: 
 549: Update `src/lib.rs`:
 550: 
 551: ```rust
 552: pub mod claude;
 553: pub mod config;
 554: pub mod session;
 555: ```
 556: 
 557: **Step 4: Run test to verify it passes**
 558: 
 559: Run:
 560: ```bash
 561: cargo test claude_
 562: ```
 563: 
 564: Expected: PASS (all 3 tests)
 565: 
 566: **Step 5: Commit claude module**
 567: 
 568: ```bash
 569: git add src/lib.rs src/claude.rs tests/claude_tests.rs
 570: git commit -m "feat(claude): add CLI spawning and JSON response parsing"
 571: ```
 572: 
 573: ---
 574: 
 575: ## Task 5: Matrix Client Module
 576: 
 577: **Files:**
 578: - Create: `src/matrix_client.rs`
 579: 
 580: **Step 1: Write matrix client initialization**
 581: 
 582: Create `src/matrix_client.rs`:
 583: 
 584: ```rust
 585: use anyhow::{Context, Result};
 586: use matrix_sdk::{
 587:     config::SyncSettings,
 588:     ruma::OwnedUserId,
 589:     Client, SqliteCryptoStore,
 590: };
 591: use std::path::Path;
 592: 
 593: pub async fn create_client(homeserver: &str, user_id: &str) -> Result<Client> {
 594:     let user_id: OwnedUserId = user_id.parse()
 595:         .context("Invalid Matrix user ID")?;
 596: 
 597:     let crypto_store = SqliteCryptoStore::open(Path::new("./crypto_store"), None)
 598:         .await
 599:         .context("Failed to open crypto store")?;
 600: 
 601:     let client = Client::builder()
 602:         .homeserver_url(homeserver)
 603:         .sqlite_crypto_store(crypto_store)
 604:         .build()
 605:         .await
 606:         .context("Failed to create Matrix client")?;
 607: 
 608:     Ok(client)
 609: }
 610: 
 611: pub async fn login(
 612:     client: &Client,
 613:     user_id: &str,
 614:     password: Option<&str>,
 615:     access_token: Option<&str>,
 616:     device_name: &str,
 617: ) -> Result<()> {
 618:     if let Some(token) = access_token {
 619:         tracing::info!("Logging in with access token");
 620:         let user_id: OwnedUserId = user_id.parse()?;
 621:         client.restore_session(matrix_sdk::Session {
 622:             access_token: token.to_string(),
 623:             user_id,
 624:             device_id: device_name.to_string().into(),
 625:         }).await?;
 626:     } else if let Some(pwd) = password {
 627:         tracing::info!("Logging in with password");
 628:         client
 629:             .matrix_auth()
 630:             .login_username(user_id, pwd)
 631:             .device_id(device_name)
 632:             .send()
 633:             .await
 634:             .context("Failed to log in")?;
 635:     } else {
 636:         anyhow::bail!("Either MATRIX_PASSWORD or MATRIX_ACCESS_TOKEN is required");
 637:     }
 638: 
 639:     tracing::info!(user_id = %client.user_id().unwrap(), "Logged in successfully");
 640: 
 641:     Ok(())
 642: }
 643: ```
 644: 
 645: Update `src/lib.rs`:
 646: 
 647: ```rust
 648: pub mod claude;
 649: pub mod config;
 650: pub mod matrix_client;
 651: pub mod session;
 652: ```
 653: 
 654: **Step 2: Verify it compiles**
 655: 
 656: Run:
 657: ```bash
 658: cargo check
 659: ```
 660: 
 661: Expected: Compiles without errors
 662: 
 663: **Step 3: Commit matrix client**
 664: 
 665: ```bash
 666: git add src/lib.rs src/matrix_client.rs
 667: git commit -m "feat(matrix): add client initialization and login"
 668: ```
 669: 
 670: ---
 671: 
 672: ## Task 6: Message Handler Module
 673: 
 674: **Files:**
 675: - Create: `src/message_handler.rs`
 676: 
 677: **Step 1: Write message handler**
 678: 
 679: Create `src/message_handler.rs`:
 680: 
 681: ```rust
 682: use anyhow::Result;
 683: use matrix_sdk::{
 684:     room::Room,
 685:     ruma::{events::room::message::RoomMessageEventContent, OwnedUserId},
 686:     Client,
 687: };
 688: use std::collections::HashSet;
 689: 
 690: use crate::{claude, config::Config, session::SessionStore};
 691: 
 692: pub async fn handle_message(
 693:     room: Room,
 694:     event: matrix_sdk::event_handler::EventHandlerData,
 695:     client: Client,
 696:     config: Config,
 697:     session_store: SessionStore,
 698: ) -> Result<()> {
 699:     let Room::Joined(room) = room else {
 700:         return Ok(());
 701:     };
 702: 
 703:     // Only process messages from configured room
 704:     if room.room_id().as_str() != config.matrix_room_id {
 705:         return Ok(());
 706:     }
 707: 
 708:     let Some(message_event) = event.event().as_original() else {
 709:         return Ok(());
 710:     };
 711: 
 712:     let sender = message_event.sender.as_str();
 713:     let body = &message_event.content.body;
 714: 
 715:     // Ignore bot's own messages
 716:     if sender == client.user_id().unwrap().as_str() {
 717:         return Ok(());
 718:     }
 719: 
 720:     // Check whitelist
 721:     if !config.allowed_users.contains(sender) {
 722:         tracing::debug!(sender, "Ignoring message from unauthorized user");
 723:         return Ok(());
 724:     }
 725: 
 726:     tracing::info!(sender, room_id = %room.room_id(), message_preview = &body[..body.len().min(50)], "Processing message");
 727: 
 728:     // Load session
 729:     let session = session_store.get_or_create(room.room_id().as_str())?;
 730:     let session_args = session.cli_args();
 731: 
 732:     // Set typing indicator
 733:     room.typing_notice(true).await?;
 734: 
 735:     // Invoke Claude
 736:     let response = match claude::invoke_claude(
 737:         &config.claude_binary_path,
 738:         config.claude_sdk_url.as_deref(),
 739:         session_args,
 740:         body,
 741:     ).await {
 742:         Ok(resp) => {
 743:             tracing::info!(response_length = resp.len(), "Claude responded");
 744:             resp
 745:         }
 746:         Err(e) => {
 747:             tracing::error!(error = %e, "Claude invocation failed");
 748:             let error_msg = format!("‚ö†Ô∏è Claude error: {}", e);
 749:             room.typing_notice(false).await?;
 750:             room.send(RoomMessageEventContent::text_plain(&error_msg)).await?;
 751:             return Ok(());
 752:         }
 753:     };
 754: 
 755:     // Clear typing indicator
 756:     room.typing_notice(false).await?;
 757: 
 758:     // Send response
 759:     room.send(RoomMessageEventContent::text_plain(&response)).await?;
 760: 
 761:     // Mark session as started
 762:     session_store.mark_started(room.room_id().as_str())?;
 763: 
 764:     tracing::info!("Response sent successfully");
 765: 
 766:     Ok(())
 767: }
 768: ```
 769: 
 770: Update `src/lib.rs`:
 771: 
 772: ```rust
 773: pub mod claude;
 774: pub mod config;
 775: pub mod matrix_client;
 776: pub mod message_handler;
 777: pub mod session;
 778: ```
 779: 
 780: **Step 2: Verify it compiles**
 781: 
 782: Run:
 783: ```bash
 784: cargo check
 785: ```
 786: 
 787: Expected: Compiles without errors
 788: 
 789: **Step 3: Commit message handler**
 790: 
 791: ```bash
 792: git add src/lib.rs src/message_handler.rs
 793: git commit -m "feat(handler): add message processing with auth and Claude invocation"
 794: ```
 795: 
 796: ---
 797: 
 798: ## Task 7: Main Binary
 799: 
 800: **Files:**
 801: - Create: `src/main.rs`
 802: 
 803: **Step 1: Write main entry point**
 804: 
 805: Create `src/main.rs`:
 806: 
 807: ```rust
 808: use anyhow::Result;
 809: use matrix_bridge::{config::Config, matrix_client, message_handler, session::SessionStore};
 810: use matrix_sdk::{
 811:     config::SyncSettings,
 812:     ruma::events::room::message::SyncRoomMessageEvent,
 813: };
 814: use std::sync::Arc;
 815: use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
 816: 
 817: #[tokio::main]
 818: async fn main() -> Result<()> {
 819:     // Initialize logging
 820:     tracing_subscriber::registry()
 821:         .with(
 822:             tracing_subscriber::EnvFilter::try_from_default_env()
 823:                 .unwrap_or_else(|_| "info".into()),
 824:         )
 825:         .with(tracing_subscriber::fmt::layer())
 826:         .init();
 827: 
 828:     tracing::info!("Starting Matrix-Claude Bridge");
 829: 
 830:     // Load configuration
 831:     dotenvy::dotenv().ok();
 832:     let config = Config::from_env()?;
 833: 
 834:     tracing::info!(
 835:         homeserver = %config.matrix_home_server,
 836:         user_id = %config.matrix_user_id,
 837:         room_id = %config.matrix_room_id,
 838:         allowed_users = config.allowed_users.len(),
 839:         "Configuration loaded"
 840:     );
 841: 
 842:     // Initialize session store
 843:     let session_store = SessionStore::new("./sessions_db")?;
 844:     tracing::info!("Session store initialized");
 845: 
 846:     // Create Matrix client
 847:     let client = matrix_client::create_client(
 848:         &config.matrix_home_server,
 849:         &config.matrix_user_id,
 850:     ).await?;
 851: 
 852:     // Login
 853:     matrix_client::login(
 854:         &client,
 855:         &config.matrix_user_id,
 856:         config.matrix_password.as_deref(),
 857:         config.matrix_access_token.as_deref(),
 858:         &config.matrix_device_name,
 859:     ).await?;
 860: 
 861:     // Join room
 862:     let room_id: matrix_sdk::ruma::OwnedRoomId = config.matrix_room_id.parse()?;
 863:     client.join_room_by_id(&room_id).await?;
 864:     tracing::info!(room_id = %config.matrix_room_id, "Joined room");
 865: 
 866:     // Register message handler
 867:     let config_clone = Arc::new(config);
 868:     let session_store_clone = Arc::new(session_store);
 869: 
 870:     client.add_event_handler(
 871:         move |event: SyncRoomMessageEvent, room, client| {
 872:             let config = Arc::clone(&config_clone);
 873:             let session_store = Arc::clone(&session_store_clone);
 874:             async move {
 875:                 if let Err(e) = message_handler::handle_message(
 876:                     room,
 877:                     event.into(),
 878:                     client,
 879:                     (*config).clone(),
 880:                     (*session_store).clone(),
 881:                 ).await {
 882:                     tracing::error!(error = %e, "Error handling message");
 883:                 }
 884:             }
 885:         },
 886:     );
 887: 
 888:     tracing::info!("Message handler registered, starting sync loop");
 889: 
 890:     // Sync forever
 891:     client.sync(SyncSettings::default()).await?;
 892: 
 893:     Ok(())
 894: }
 895: ```
 896: 
 897: **Step 2: Fix SessionStore to be cloneable**
 898: 
 899: Update `src/session.rs` to add Clone:
 900: 
 901: ```rust
 902: #[derive(Clone)]
 903: pub struct SessionStore {
 904:     db: sled::Db,
 905: }
 906: ```
 907: 
 908: **Step 3: Build the binary**
 909: 
 910: Run:
 911: ```bash
 912: cargo build --release
 913: ```
 914: 
 915: Expected: Builds successfully
 916: 
 917: **Step 4: Commit main binary**
 918: 
 919: ```bash
 920: git add src/main.rs src/session.rs
 921: git commit -m "feat(main): add main entry point with sync loop"
 922: ```
 923: 
 924: ---
 925: 
 926: ## Task 8: Integration Test (Manual)
 927: 
 928: **Files:**
 929: - Create: `docs/testing.md`
 930: 
 931: **Step 1: Create testing documentation**
 932: 
 933: Create `docs/testing.md`:
 934: 
 935: ```markdown
 936: # Testing Guide
 937: 
 938: ## Setup
 939: 
 940: 1. Copy `.env.example` to `.env`
 941: 2. Configure with real Matrix credentials
 942: 3. Create a test room with E2E encryption enabled
 943: 4. Add your bot user to the room
 944: 5. Add your personal user ID to `ALLOWED_USERS`
 945: 
 946: ## First Run
 947: 
 948: ```bash
 949: cargo run --release
 950: ```
 951: 
 952: Expected output:
 953: ```
 954: INFO Starting Matrix-Claude Bridge
 955: INFO Configuration loaded
 956: INFO Session store initialized
 957: INFO Logged in successfully
 958: INFO Joined room
 959: INFO Message handler registered, starting sync loop
 960: ```
 961: 
 962: ## Device Verification
 963: 
 964: On first run, the bot creates a new device. You must verify it:
 965: 
 966: 1. Open Element (or another Matrix client)
 967: 2. Go to Settings ‚Üí Security ‚Üí Verify this device
 968: 3. Complete emoji verification or cross-signing
 969: 4. Return to terminal and send a message
 970: 
 971: ## Test Cases
 972: 
 973: ### 1. Authorized User Message
 974: 
 975: Send: "Hello Claude!"
 976: 
 977: Expected:
 978: - Bot sets typing indicator
 979: - Claude CLI is invoked
 980: - Response appears in room
 981: - Logs show session ID created
 982: 
 983: ### 2. Follow-up Message
 984: 
 985: Send: "What did I just say?"
 986: 
 987: Expected:
 988: - Bot uses `--resume` with same session ID
 989: - Claude has context from previous message
 990: - Response references "Hello Claude!"
 991: 
 992: ### 3. Unauthorized User
 993: 
 994: Add another user to room (not in whitelist)
 995: 
 996: Send message as that user
 997: 
 998: Expected:
 999: - Bot ignores message silently
1000: - Logs show "Ignoring message from unauthorized user"
1001: 
1002: ### 4. Bot Restart Persistence
1003: 
1004: Stop bot (Ctrl+C), restart
1005: 
1006: Send message
1007: 
1008: Expected:
1009: - Bot resumes with same session ID
1010: - Context is preserved
1011: 
1012: ### 5. Decryption Test
1013: 
1014: Send encrypted message from verified device
1015: 
1016: Expected:
1017: - Bot decrypts and processes message normally
1018: 
1019: Send from unverified device
1020: 
1021: Expected:
1022: - Bot logs decryption failure
1023: - Sends error message to room
1024: ```
1025: 
1026: **Step 2: Commit testing docs**
1027: 
1028: ```bash
1029: git add docs/testing.md
1030: git commit -m "docs: add integration testing guide"
1031: ```
1032: 
1033: ---
1034: 
1035: ## Task 9: Final Polish
1036: 
1037: **Files:**
1038: - Modify: `README.md`
1039: - Create: `.env.example` (enhance with comments)
1040: 
1041: **Step 1: Enhance README**
1042: 
1043: Update `README.md`:
1044: 
1045: ```markdown
1046: # Matrix-Claude Bridge
1047: 
1048: Rust bot that bridges Matrix room messages to Claude Code CLI with E2E encryption and persistent sessions.
1049: 
1050: ## Features
1051: 
1052: - **E2E Encryption**: Full support for encrypted Matrix rooms
1053: - **Whitelist Auth**: Only respond to approved users
1054: - **Persistent Sessions**: Conversation context survives restarts
1055: - **Structured Logging**: Trace message flow with tracing
1056: - **Zero Prefix**: Responds to all messages (no `!command` needed)
1057: 
1058: ## Setup
1059: 
1060: ### 1. Prerequisites
1061: 
1062: - Rust 1.70+ (`rustup` recommended)
1063: - Claude Code CLI installed and authenticated
1064: - Matrix account for the bot
1065: - Matrix room with E2E encryption enabled
1066: 
1067: ### 2. Configuration
1068: 
1069: Copy `.env.example` to `.env` and configure:
1070: 
1071: ```bash
1072: cp .env.example .env
1073: # Edit .env with your credentials
1074: ```
1075: 
1076: ### 3. Build and Run
1077: 
1078: ```bash
1079: cargo build --release
1080: cargo run --release
1081: ```
1082: 
1083: ### 4. Device Verification (First Run Only)
1084: 
1085: The bot creates a new Matrix device on first login. Verify it from another client:
1086: 
1087: 1. Open Element ‚Üí Settings ‚Üí Security
1088: 2. Find the new "claude-matrix-bridge" device
1089: 3. Verify using emoji verification or cross-signing
1090: 
1091: ## Usage
1092: 
1093: Once running, send any message in the configured room (as a whitelisted user). The bot responds with Claude's output. Conversation context persists across messages and bot restarts.
1094: 
1095: ## Troubleshooting
1096: 
1097: **Bot doesn't respond:**
1098: - Check logs for "Ignoring message from unauthorized user"
1099: - Verify your user ID is in `ALLOWED_USERS`
1100: - Confirm bot joined the correct room
1101: 
1102: **Decryption failures:**
1103: - Verify the bot's device from another client
1104: - Check `crypto_store/` exists and has correct permissions
1105: 
1106: **Claude errors:**
1107: - Verify `claude` binary is in PATH or set `CLAUDE_BINARY_PATH`
1108: - Check Claude CLI is authenticated: `claude auth status`
1109: 
1110: ## Architecture
1111: 
1112: - `src/config.rs` - Environment variable parsing
1113: - `src/session.rs` - Persistent session storage (sled)
1114: - `src/claude.rs` - CLI spawning and JSON parsing
1115: - `src/matrix_client.rs` - Matrix login and crypto setup
1116: - `src/message_handler.rs` - Auth checks and orchestration
1117: - `src/main.rs` - Entry point and sync loop
1118: 
1119: ## License
1120: 
1121: MIT
1122: ```
1123: 
1124: **Step 2: Commit final polish**
1125: 
1126: ```bash
1127: git add README.md
1128: git commit -m "docs: enhance README with features and troubleshooting"
1129: ```
1130: 
1131: ---
1132: 
1133: ## Task 10: Final Verification
1134: 
1135: **Step 1: Clean build**
1136: 
1137: Run:
1138: ```bash
1139: cargo clean
1140: cargo build --release
1141: ```
1142: 
1143: Expected: Clean build succeeds
1144: 
1145: **Step 2: Run all tests**
1146: 
1147: Run:
1148: ```bash
1149: cargo test
1150: ```
1151: 
1152: Expected: All tests pass
1153: 
1154: **Step 3: Check for warnings**
1155: 
1156: Run:
1157: ```bash
1158: cargo clippy
1159: ```
1160: 
1161: Expected: No warnings (or only minor ones)
1162: 
1163: **Step 4: Tag release**
1164: 
1165: ```bash
1166: git tag -a v0.1.0 -m "Initial release: Matrix-Claude bridge with E2E encryption"
1167: ```
1168: 
1169: ---
1170: 
1171: ## Verification Checklist
1172: 
1173: Before declaring complete:
1174: 
1175: - [ ] `cargo build --release` succeeds
1176: - [ ] `cargo test` all pass
1177: - [ ] `cargo clippy` clean (or acceptable warnings)
1178: - [ ] `.env.example` has all required variables documented
1179: - [ ] README explains setup, usage, troubleshooting
1180: - [ ] Manual test: bot responds to authorized user
1181: - [ ] Manual test: bot ignores unauthorized user
1182: - [ ] Manual test: session persists across restart
1183: - [ ] Manual test: E2E encryption works
1184: 
1185: ---
1186: 
1187: ## Post-Implementation
1188: 
1189: After completing all tasks, perform manual integration testing per `docs/testing.md`. The bot should:
1190: 
1191: 1. Start up and log in successfully
1192: 2. Join the configured room
1193: 3. Respond to whitelisted users only
1194: 4. Maintain session context across messages
1195: 5. Persist sessions across restarts
1196: 6. Handle encrypted messages after device verification
</file>

<file path="docs/plans/2025-12-03-github-actions-cicd-design.md">
  1: # GitHub Actions CI/CD Design
  2: 
  3: **Date:** 2025-12-03
  4: **Project:** matrix-bridge
  5: **Status:** Validated
  6: 
  7: ## Overview
  8: 
  9: This document describes the GitHub Actions CI/CD system for the matrix-bridge project. The system automatically checks code quality on every commit and automatically builds releases for Linux and macOS when tags are pushed.
 10: 
 11: ## Architecture
 12: 
 13: Two main workflows form the system:
 14: 
 15: 1. **CI Workflow** (`ci.yml`) - Quality gates for every push and PR
 16: 2. **Release Workflow** (`release.yml`) - Build and publish releases on git tags
 17: 
 18: Both workflows use aggressive caching strategies to maximize build speed while maintaining cache invalidation when dependencies change.
 19: 
 20: ## CI Workflow (`ci.yml`)
 21: 
 22: ### Triggers
 23: 
 24: - Push to any branch
 25: - All pull requests
 26: 
 27: ### Job Structure
 28: 
 29: Three parallel jobs provide fast feedback:
 30: 
 31: **Job 1: Format Check**
 32: - Runs `cargo fmt --all -- --check`
 33: - Rejects improperly formatted code
 34: - Completes in ~10 seconds
 35: - Requires no caching
 36: 
 37: **Job 2: Clippy Lint**
 38: - Runs `cargo clippy --all-targets --all-features -- -D warnings`
 39: - Treats all warnings as errors (strict mode)
 40: - Uses aggressive caching strategy
 41: - Takes ~30 seconds with cache, ~2 minutes cold
 42: 
 43: **Job 3: Test Suite**
 44: - Runs `cargo test --all-features`
 45: - Executes all 8 unit tests
 46: - Uses aggressive caching strategy
 47: - Takes ~30 seconds with cache, ~3 minutes cold
 48: 
 49: ### Rust Toolchain
 50: 
 51: - Uses stable channel (always latest)
 52: - Automatically updates to newest stable Rust
 53: - Requires no version pinning
 54: 
 55: ### Caching Strategy
 56: 
 57: Aggressive caching with smart invalidation:
 58: 
 59: **Cache Key:** `rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}`
 60: 
 61: **Cached Paths:**
 62: - `~/.cargo/bin/`
 63: - `~/.cargo/registry/index/`
 64: - `~/.cargo/registry/cache/`
 65: - `~/.cargo/git/db/`
 66: - `target/`
 67: 
 68: **Invalidation:** The cache automatically invalidates when `Cargo.lock` changes.
 69: 
 70: **Restore Fallbacks:** OS-specific fallbacks restore previous builds when the lockfile changes.
 71: 
 72: ### Branch Protection
 73: 
 74: Configure GitHub to require all three jobs to pass before merging PRs.
 75: 
 76: ## Release Workflow (`release.yml`)
 77: 
 78: ### Trigger
 79: 
 80: Pushing a git tag matching `v*` pattern:
 81: 
 82: ```bash
 83: git tag v0.2.0
 84: git push origin v0.2.0
 85: ```
 86: 
 87: ### Build Matrix
 88: 
 89: Cross-platform builds using matrix strategy:
 90: 
 91: | Platform | Target Triple | Artifact Name |
 92: |----------|--------------|---------------|
 93: | Linux x86_64 | `x86_64-unknown-linux-gnu` | `matrix-bridge-linux-x86_64` |
 94: | macOS x86_64 | `x86_64-apple-darwin` | `matrix-bridge-macos-x86_64` |
 95: 
 96: ### Build Steps
 97: 
 98: For each platform, the workflow:
 99: 
100: 1. Checks out code with full git history (for changelog generation)
101: 2. Installs Rust stable toolchain with target support
102: 3. Restores aggressive cache (same strategy as CI)
103: 4. Builds release binary: `cargo build --release --target $TARGET`
104: 5. Strips debug symbols: `strip target/$TARGET/release/matrix-bridge`
105: 6. Renames to artifact name (e.g., `matrix-bridge-linux-x86_64`)
106: 7. Uploads artifact for release creation
107: 
108: ### Release Creation
109: 
110: After both platform builds complete:
111: 
112: 1. Downloads both platform artifacts
113: 2. Generates changelog from commits between current tag and previous tag
114: 3. Parses conventional commits (feat/fix/docs/chore)
115: 4. Creates GitHub release with:
116:    - Auto-generated release notes grouped by type
117:    - Both platform binaries attached
118:    - Tag name as release title
119: 
120: ### Release Notes Format
121: 
122: Auto-generated from conventional commits:
123: 
124: ```markdown
125: ## Features
126: - feat: description of feature
127: 
128: ## Bug Fixes
129: - fix: description of fix
130: 
131: ## Documentation
132: - docs: description of doc change
133: 
134: ## Chores
135: - chore: description of chore
136: ```
137: 
138: Users may edit release notes in the GitHub UI after creation.
139: 
140: ## Binary Naming Convention
141: 
142: A simple platform suffix format:
143: - `matrix-bridge-linux-x86_64`
144: - `matrix-bridge-macos-x86_64`
145: 
146: This naming clearly indicates which binary to download for each platform.
147: 
148: ## Performance Expectations
149: 
150: ### CI Workflow
151: - **With cache hit:** ~30 seconds total
152: - **Cold build:** ~3 minutes total
153: - **Format check:** ~10 seconds
154: 
155: ### Release Workflow
156: - **Full build (both platforms):** ~5-7 minutes
157: - **Per-platform build:** ~3-4 minutes
158: 
159: ## Future Enhancements
160: 
161: The following additions remain candidates for future implementation:
162: 
163: - ARM64 builds (Linux and macOS)
164: - Security audit with cargo-audit
165: - License compliance checking with cargo-deny
166: - Nightly Rust builds for early warning
167: - Performance benchmarking
168: - Docker image builds
169: 
170: ## Implementation Files
171: 
172: The implementation creates:
173: 
174: - `.github/workflows/ci.yml` - CI workflow
175: - `.github/workflows/release.yml` - Release workflow
176: - `.github/dependabot.yml` - Optional: automated dependency updates
177: 
178: ## Testing the Workflows
179: 
180: ### Testing CI
181: ```bash
182: git checkout -b test-ci
183: # Make a change
184: git commit -m "test: verify CI workflow"
185: git push origin test-ci
186: # Open PR and verify all three jobs pass
187: ```
188: 
189: ### Testing Release
190: ```bash
191: git tag v0.2.0-test
192: git push origin v0.2.0-test
193: # Verify workflow runs and creates release with binaries
194: # Delete test release and tag after verification
195: ```
196: 
197: ## Dependencies
198: 
199: Workflows require only standard GitHub Actions and Rust tooling. No new dependencies are needed in `Cargo.toml`.
200: 
201: ## Maintenance
202: 
203: - **Rust updates:** Automatic via stable channel
204: - **Action updates:** Dependabot can manage GitHub Action versions
205: - **Cache cleanup:** GitHub automatically evicts old caches after 7 days
206: 
207: ## Success Criteria
208: 
209: The CI/CD system succeeds when:
210: 
211: 1. All pushes and PRs trigger quality checks automatically
212: 2. Failed checks prevent merging (with branch protection)
213: 3. Tagging a version creates a release with binaries within 10 minutes
214: 4. Binaries work on target platforms (Linux and macOS x86_64)
215: 5. Release notes accurately reflect changes since the last version
216: 6. Build times remain under 5 minutes with caching
</file>

<file path="docs/plans/2025-12-03-github-actions-cicd-implementation.md">
  1: # GitHub Actions CI/CD Implementation Plan
  2: 
  3: > **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.
  4: 
  5: **Goal:** Implement automated CI/CD system with quality checks on every commit and cross-platform release builds on git tags.
  6: 
  7: **Architecture:** Two GitHub Actions workflows - ci.yml runs format/lint/test in parallel on all pushes and PRs, release.yml builds Linux and macOS binaries and creates GitHub releases when v* tags are pushed. Both use aggressive caching with Cargo.lock-based invalidation.
  8: 
  9: **Tech Stack:** GitHub Actions, Rust stable toolchain, actions/cache for caching, actions/checkout for code checkout
 10: 
 11: ---
 12: 
 13: ## Task 1: Create GitHub Workflows Directory
 14: 
 15: **Files:**
 16: - Create: `.github/workflows/`
 17: 
 18: **Step 1: Create the directory**
 19: 
 20: ```bash
 21: mkdir -p .github/workflows
 22: ```
 23: 
 24: **Step 2: Verify directory exists**
 25: 
 26: ```bash
 27: ls -la .github/
 28: ```
 29: 
 30: Expected: Directory `.github/workflows/` exists
 31: 
 32: **Step 3: Commit**
 33: 
 34: ```bash
 35: git add .github/workflows/.gitkeep
 36: touch .github/workflows/.gitkeep
 37: git add .github/workflows/.gitkeep
 38: git commit -m "chore: create GitHub workflows directory"
 39: ```
 40: 
 41: ---
 42: 
 43: ## Task 2: Implement CI Workflow
 44: 
 45: **Files:**
 46: - Create: `.github/workflows/ci.yml`
 47: 
 48: **Step 1: Create CI workflow file**
 49: 
 50: Create `.github/workflows/ci.yml` with complete configuration:
 51: 
 52: ```yaml
 53: name: CI
 54: 
 55: on:
 56:   push:
 57:     branches: [ "*" ]
 58:   pull_request:
 59:     branches: [ "*" ]
 60: 
 61: jobs:
 62:   format:
 63:     name: Format Check
 64:     runs-on: ubuntu-latest
 65:     steps:
 66:       - name: Checkout code
 67:         uses: actions/checkout@v4
 68: 
 69:       - name: Install Rust stable
 70:         uses: dtolnay/rust-toolchain@stable
 71:         with:
 72:           components: rustfmt
 73: 
 74:       - name: Run rustfmt check
 75:         run: cargo fmt --all -- --check
 76: 
 77:   clippy:
 78:     name: Clippy Lint
 79:     runs-on: ubuntu-latest
 80:     steps:
 81:       - name: Checkout code
 82:         uses: actions/checkout@v4
 83: 
 84:       - name: Install Rust stable
 85:         uses: dtolnay/rust-toolchain@stable
 86:         with:
 87:           components: clippy
 88: 
 89:       - name: Cache cargo registry
 90:         uses: actions/cache@v4
 91:         with:
 92:           path: |
 93:             ~/.cargo/bin/
 94:             ~/.cargo/registry/index/
 95:             ~/.cargo/registry/cache/
 96:             ~/.cargo/git/db/
 97:             target/
 98:           key: rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
 99:           restore-keys: |
100:             rust-cache-${{ runner.os }}-
101: 
102:       - name: Run clippy
103:         run: cargo clippy --all-targets --all-features -- -D warnings
104: 
105:   test:
106:     name: Test Suite
107:     runs-on: ubuntu-latest
108:     steps:
109:       - name: Checkout code
110:         uses: actions/checkout@v4
111: 
112:       - name: Install Rust stable
113:         uses: dtolnay/rust-toolchain@stable
114: 
115:       - name: Cache cargo registry
116:         uses: actions/cache@v4
117:         with:
118:           path: |
119:             ~/.cargo/bin/
120:             ~/.cargo/registry/index/
121:             ~/.cargo/registry/cache/
122:             ~/.cargo/git/db/
123:             target/
124:           key: rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
125:           restore-keys: |
126:             rust-cache-${{ runner.os }}-
127: 
128:       - name: Run tests
129:         run: cargo test --all-features
130: ```
131: 
132: **Step 2: Verify YAML syntax**
133: 
134: ```bash
135: cat .github/workflows/ci.yml
136: ```
137: 
138: Expected: File contents display correctly, no syntax errors visible
139: 
140: **Step 3: Commit**
141: 
142: ```bash
143: git add .github/workflows/ci.yml
144: git commit -m "feat(ci): add CI workflow with format, lint, and test jobs
145: 
146: - Three parallel jobs for fast feedback
147: - Format check with cargo fmt
148: - Clippy linting with warnings as errors
149: - Test suite execution
150: - Aggressive caching with Cargo.lock invalidation"
151: ```
152: 
153: ---
154: 
155: ## Task 3: Implement Release Workflow
156: 
157: **Files:**
158: - Create: `.github/workflows/release.yml`
159: 
160: **Step 1: Create release workflow file**
161: 
162: Create `.github/workflows/release.yml` with complete configuration:
163: 
164: ```yaml
165: name: Release
166: 
167: on:
168:   push:
169:     tags:
170:       - 'v*'
171: 
172: jobs:
173:   build:
174:     name: Build ${{ matrix.platform }}
175:     runs-on: ${{ matrix.os }}
176:     strategy:
177:       matrix:
178:         include:
179:           - os: ubuntu-latest
180:             target: x86_64-unknown-linux-gnu
181:             platform: Linux x86_64
182:             artifact_name: matrix-bridge-linux-x86_64
183:           - os: macos-latest
184:             target: x86_64-apple-darwin
185:             platform: macOS x86_64
186:             artifact_name: matrix-bridge-macos-x86_64
187: 
188:     steps:
189:       - name: Checkout code
190:         uses: actions/checkout@v4
191:         with:
192:           fetch-depth: 0
193: 
194:       - name: Install Rust stable
195:         uses: dtolnay/rust-toolchain@stable
196:         with:
197:           targets: ${{ matrix.target }}
198: 
199:       - name: Cache cargo registry
200:         uses: actions/cache@v4
201:         with:
202:           path: |
203:             ~/.cargo/bin/
204:             ~/.cargo/registry/index/
205:             ~/.cargo/registry/cache/
206:             ~/.cargo/git/db/
207:             target/
208:           key: rust-cache-${{ matrix.os }}-${{ hashFiles('**/Cargo.lock') }}
209:           restore-keys: |
210:             rust-cache-${{ matrix.os }}-
211: 
212:       - name: Build release binary
213:         run: cargo build --release --target ${{ matrix.target }}
214: 
215:       - name: Strip binary (Linux)
216:         if: matrix.os == 'ubuntu-latest'
217:         run: strip target/${{ matrix.target }}/release/matrix-bridge
218: 
219:       - name: Strip binary (macOS)
220:         if: matrix.os == 'macos-latest'
221:         run: strip target/${{ matrix.target }}/release/matrix-bridge
222: 
223:       - name: Rename binary
224:         run: |
225:           cp target/${{ matrix.target }}/release/matrix-bridge ${{ matrix.artifact_name }}
226: 
227:       - name: Upload artifact
228:         uses: actions/upload-artifact@v4
229:         with:
230:           name: ${{ matrix.artifact_name }}
231:           path: ${{ matrix.artifact_name }}
232:           if-no-files-found: error
233: 
234:   release:
235:     name: Create Release
236:     needs: build
237:     runs-on: ubuntu-latest
238:     permissions:
239:       contents: write
240: 
241:     steps:
242:       - name: Checkout code
243:         uses: actions/checkout@v4
244:         with:
245:           fetch-depth: 0
246: 
247:       - name: Download Linux artifact
248:         uses: actions/download-artifact@v4
249:         with:
250:           name: matrix-bridge-linux-x86_64
251:           path: ./artifacts
252: 
253:       - name: Download macOS artifact
254:         uses: actions/download-artifact@v4
255:         with:
256:           name: matrix-bridge-macos-x86_64
257:           path: ./artifacts
258: 
259:       - name: Generate changelog
260:         id: changelog
261:         run: |
262:           # Get previous tag
263:           PREV_TAG=$(git tag --sort=-v:refname | grep -v "^${GITHUB_REF_NAME}$" | head -n 1)
264: 
265:           if [ -z "$PREV_TAG" ]; then
266:             echo "No previous tag found, using all commits"
267:             COMMITS=$(git log --pretty=format:"- %s" $GITHUB_REF_NAME)
268:           else
269:             echo "Generating changelog from $PREV_TAG to $GITHUB_REF_NAME"
270:             COMMITS=$(git log --pretty=format:"- %s" $PREV_TAG..$GITHUB_REF_NAME)
271:           fi
272: 
273:           # Group by conventional commit type
274:           FEATURES=$(echo "$COMMITS" | grep "^- feat:" || true)
275:           FIXES=$(echo "$COMMITS" | grep "^- fix:" || true)
276:           DOCS=$(echo "$COMMITS" | grep "^- docs:" || true)
277:           CHORES=$(echo "$COMMITS" | grep "^- chore:" || true)
278: 
279:           # Build changelog
280:           CHANGELOG="## Changes in $GITHUB_REF_NAME"
281: 
282:           if [ -n "$FEATURES" ]; then
283:             CHANGELOG="$CHANGELOG\n\n### Features\n$FEATURES"
284:           fi
285: 
286:           if [ -n "$FIXES" ]; then
287:             CHANGELOG="$CHANGELOG\n\n### Bug Fixes\n$FIXES"
288:           fi
289: 
290:           if [ -n "$DOCS" ]; then
291:             CHANGELOG="$CHANGELOG\n\n### Documentation\n$DOCS"
292:           fi
293: 
294:           if [ -n "$CHORES" ]; then
295:             CHANGELOG="$CHANGELOG\n\n### Chores\n$CHORES"
296:           fi
297: 
298:           # Save to file and output
299:           echo -e "$CHANGELOG" > changelog.md
300:           echo "changelog<<EOF" >> $GITHUB_OUTPUT
301:           cat changelog.md >> $GITHUB_OUTPUT
302:           echo "EOF" >> $GITHUB_OUTPUT
303: 
304:       - name: Create GitHub Release
305:         uses: softprops/action-gh-release@v1
306:         with:
307:           body: ${{ steps.changelog.outputs.changelog }}
308:           files: |
309:             ./artifacts/matrix-bridge-linux-x86_64
310:             ./artifacts/matrix-bridge-macos-x86_64
311:           fail_on_unmatched_files: true
312:         env:
313:           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
314: ```
315: 
316: **Step 2: Verify YAML syntax**
317: 
318: ```bash
319: cat .github/workflows/release.yml
320: ```
321: 
322: Expected: File contents display correctly, no syntax errors visible
323: 
324: **Step 3: Commit**
325: 
326: ```bash
327: git add .github/workflows/release.yml
328: git commit -m "feat(ci): add release workflow with cross-platform builds
329: 
330: - Matrix builds for Linux x86_64 and macOS x86_64
331: - Automated binary stripping to reduce size
332: - Auto-generated changelog from conventional commits
333: - GitHub release creation with binaries attached
334: - Triggered on v* tags"
335: ```
336: 
337: ---
338: 
339: ## Task 4: Add Dependabot Configuration (Optional)
340: 
341: **Files:**
342: - Create: `.github/dependabot.yml`
343: 
344: **Step 1: Create dependabot config**
345: 
346: Create `.github/dependabot.yml`:
347: 
348: ```yaml
349: version: 2
350: updates:
351:   # Keep Rust dependencies up to date
352:   - package-ecosystem: "cargo"
353:     directory: "/"
354:     schedule:
355:       interval: "weekly"
356:     open-pull-requests-limit: 10
357: 
358:   # Keep GitHub Actions up to date
359:   - package-ecosystem: "github-actions"
360:     directory: "/"
361:     schedule:
362:       interval: "weekly"
363:     open-pull-requests-limit: 5
364: ```
365: 
366: **Step 2: Verify YAML syntax**
367: 
368: ```bash
369: cat .github/dependabot.yml
370: ```
371: 
372: Expected: File contents display correctly
373: 
374: **Step 3: Commit**
375: 
376: ```bash
377: git add .github/dependabot.yml
378: git commit -m "chore(ci): add Dependabot configuration
379: 
380: - Weekly Cargo dependency updates
381: - Weekly GitHub Actions updates
382: - Controlled PR limits to avoid noise"
383: ```
384: 
385: ---
386: 
387: ## Task 5: Verify CI Workflow Locally
388: 
389: **Files:**
390: - None (verification only)
391: 
392: **Step 1: Run format check**
393: 
394: ```bash
395: cargo fmt --all -- --check
396: ```
397: 
398: Expected: `Diff in /path/to/file.rs at line X` or no output if formatted
399: 
400: **Step 2: Run clippy**
401: 
402: ```bash
403: cargo clippy --all-targets --all-features -- -D warnings
404: ```
405: 
406: Expected: `Finished dev [unoptimized + debuginfo] target(s)` with 0 warnings
407: 
408: **Step 3: Run tests**
409: 
410: ```bash
411: cargo test --all-features
412: ```
413: 
414: Expected: `test result: ok. 8 passed; 0 failed`
415: 
416: **Step 4: Verify all checks pass**
417: 
418: All three commands above should succeed. If any fail, fix the issues before pushing.
419: 
420: ---
421: 
422: ## Task 6: Push and Verify CI Workflow on GitHub
423: 
424: **Files:**
425: - None (verification only)
426: 
427: **Step 1: Push to remote**
428: 
429: ```bash
430: git push origin main
431: ```
432: 
433: Expected: Push succeeds
434: 
435: **Step 2: Check GitHub Actions tab**
436: 
437: Navigate to repository on GitHub ‚Üí Actions tab
438: 
439: Expected: CI workflow triggered and running with three parallel jobs
440: 
441: **Step 3: Verify all jobs pass**
442: 
443: Wait for workflow to complete
444: 
445: Expected: All three jobs (format, clippy, test) show green checkmarks
446: 
447: ---
448: 
449: ## Task 7: Test Release Workflow with Test Tag
450: 
451: **Files:**
452: - None (verification only)
453: 
454: **Step 1: Create test tag**
455: 
456: ```bash
457: git tag v0.1.1-test
458: git push origin v0.1.1-test
459: ```
460: 
461: Expected: Tag pushed successfully
462: 
463: **Step 2: Check GitHub Actions**
464: 
465: Navigate to repository ‚Üí Actions tab
466: 
467: Expected: Release workflow triggered
468: 
469: **Step 3: Verify workflow completes**
470: 
471: Wait for both build jobs and release job to complete
472: 
473: Expected:
474: - Both platform builds succeed
475: - Release created under Releases tab
476: - Two binaries attached to release
477: - Changelog generated from commits
478: 
479: **Step 4: Verify binaries (optional)**
480: 
481: Download both binaries from release and verify they execute on respective platforms
482: 
483: Expected: Binaries run successfully
484: 
485: **Step 5: Clean up test release**
486: 
487: Delete the test release and tag from GitHub UI
488: 
489: Expected: Test artifacts cleaned up
490: 
491: ---
492: 
493: ## Task 8: Update README with CI Badge
494: 
495: **Files:**
496: - Modify: `README.md`
497: 
498: **Step 1: Add CI badge to README**
499: 
500: Add after the title in `README.md`:
501: 
502: ```markdown
503: # Matrix-Claude Bridge
504: 
505: [![CI](https://github.com/YOUR_USERNAME/YOUR_REPO/actions/workflows/ci.yml/badge.svg)](https://github.com/YOUR_USERNAME/YOUR_REPO/actions/workflows/ci.yml)
506: ```
507: 
508: Replace `YOUR_USERNAME` and `YOUR_REPO` with actual values.
509: 
510: **Step 2: Verify badge URL**
511: 
512: Open README on GitHub and verify badge displays correctly
513: 
514: Expected: Green badge showing "CI passing"
515: 
516: **Step 3: Commit**
517: 
518: ```bash
519: git add README.md
520: git commit -m "docs: add CI status badge to README"
521: ```
522: 
523: ---
524: 
525: ## Post-Implementation Notes
526: 
527: ### Testing the Full Release Flow
528: 
529: To create a real release:
530: 
531: ```bash
532: git tag v0.2.0
533: git push origin v0.2.0
534: ```
535: 
536: This will trigger the release workflow and create a production release.
537: 
538: ### Branch Protection Setup
539: 
540: Configure on GitHub (Settings ‚Üí Branches ‚Üí Add rule for `main`):
541: - Require status checks to pass before merging
542: - Select: `Format Check`, `Clippy Lint`, `Test Suite`
543: - Require branches to be up to date before merging
544: 
545: ### Monitoring
546: 
547: - Check Actions tab regularly for workflow status
548: - Review Dependabot PRs weekly
549: - Update workflows if GitHub Actions deprecate features
550: 
551: ### Troubleshooting
552: 
553: **CI fails on format:**
554: ```bash
555: cargo fmt --all
556: git commit -am "style: format code"
557: ```
558: 
559: **CI fails on clippy:**
560: ```bash
561: cargo clippy --all-targets --all-features --fix --allow-dirty
562: git commit -am "fix: address clippy warnings"
563: ```
564: 
565: **Release build fails:**
566: - Check Cargo.toml for platform-specific dependencies
567: - Verify no platform-specific code breaks cross-compilation
568: - Review GitHub Actions logs for specific error
569: 
570: ### Future Enhancements
571: 
572: See design document section "Future Enhancements" for potential additions:
573: - ARM64 builds
574: - Security audits
575: - Performance benchmarking
576: - Docker image builds
</file>

<file path="docs/testing.md">
  1: # Testing Guide
  2: 
  3: ## Overview
  4: 
  5: This project uses a multi-layered testing approach combining unit tests, integration tests, and scenario tests to ensure reliability and correctness.
  6: 
  7: ## Test Categories
  8: 
  9: ### 1. Unit Tests (Cargo Test)
 10: 
 11: Located in `tests/` directory, these test individual modules in isolation:
 12: 
 13: - `tests/config_tests.rs` - Configuration parsing and validation
 14: - `tests/session_tests.rs` - Session persistence with sled database
 15: - `tests/claude_tests.rs` - Claude CLI response parsing
 16: 
 17: **Run unit tests:**
 18: ```bash
 19: cargo test
 20: ```
 21: 
 22: **Run specific test:**
 23: ```bash
 24: cargo test config_loads_from_env
 25: ```
 26: 
 27: **Run with output:**
 28: ```bash
 29: cargo test -- --nocapture
 30: ```
 31: 
 32: ### 2. Scenario Tests (Real Dependencies)
 33: 
 34: Located in `.scratch/` directory (gitignored), these test real system integration:
 35: 
 36: - `test_session_persistence.sh` - Real sled database operations
 37: - `test_config_parsing.sh` - Real environment variable parsing
 38: - `test_claude_json_parsing.sh` - Real JSON parsing with sample responses
 39: - `test_file_operations.sh` - Real filesystem I/O and directory creation
 40: - `test_cli_args_generation.sh` - CLI argument generation validation
 41: 
 42: **Key principles:**
 43: - **NO MOCKS** - All tests use real dependencies (real sled DB, real files, real env vars)
 44: - **Observable outcomes** - Tests verify actual system behavior
 45: - **Independent** - Scenarios can run in any order
 46: - **Self-cleaning** - Tests clean up after themselves
 47: 
 48: **Run all scenarios:**
 49: ```bash
 50: .scratch/run_all_scenarios.sh
 51: ```
 52: 
 53: **Run individual scenario:**
 54: ```bash
 55: .scratch/test_session_persistence.sh
 56: ```
 57: 
 58: ### 3. Integration Tests (Manual)
 59: 
 60: End-to-end testing with real Matrix and Claude instances:
 61: 
 62: 1. Copy `.env.example` to `.env`
 63: 2. Configure with real Matrix credentials
 64: 3. Create a test room with E2E encryption enabled
 65: 4. Add your bot user to the room
 66: 5. Add your personal user ID to `ALLOWED_USERS`
 67: 
 68: **First Run:**
 69: 
 70: ```bash
 71: cargo run --release
 72: ```
 73: 
 74: Expected output:
 75: ```
 76: INFO Starting Matrix-Claude Bridge
 77: INFO Configuration loaded
 78: INFO Session store initialized
 79: INFO Logged in successfully
 80: INFO Joined room
 81: INFO Message handler registered, starting sync loop
 82: ```
 83: 
 84: ## Test Scenarios
 85: 
 86: ### Device Verification
 87: 
 88: On first run, the bot creates a new device. You must verify it:
 89: 
 90: 1. Open Element (or another Matrix client)
 91: 2. Go to Settings ‚Üí Security ‚Üí Verify this device
 92: 3. Complete emoji verification or cross-signing
 93: 4. Return to terminal and send a message
 94: 
 95: ### Test Case 1: Authorized User Message
 96: 
 97: **Action:** Send "Hello Claude!" from whitelisted user
 98: 
 99: **Expected:**
100: - Bot sets typing indicator
101: - Claude CLI is invoked
102: - Response appears in room
103: - Logs show session ID created
104: 
105: ### Test Case 2: Follow-up Message
106: 
107: **Action:** Send "What did I just say?"
108: 
109: **Expected:**
110: - Bot uses `--resume` with same session ID
111: - Claude has context from previous message
112: - Response references "Hello Claude!"
113: 
114: ### Test Case 3: Unauthorized User
115: 
116: **Action:** Add another user to room (not in whitelist), send message as that user
117: 
118: **Expected:**
119: - Bot ignores message silently
120: - Logs show "Ignoring message from unauthorized user"
121: 
122: ### Test Case 4: Bot Restart Persistence
123: 
124: **Action:** Stop bot (Ctrl+C), restart, send message
125: 
126: **Expected:**
127: - Bot resumes with same session ID
128: - Context is preserved
129: 
130: ### Test Case 5: Decryption Test
131: 
132: **Action 1:** Send encrypted message from verified device
133: 
134: **Expected:**
135: - Bot decrypts and processes message normally
136: 
137: **Action 2:** Send from unverified device
138: 
139: **Expected:**
140: - Bot logs decryption failure
141: - Sends error message to room
142: 
143: ## Scenario Test Details
144: 
145: ### Session Persistence (`test_session_persistence.sh`)
146: 
147: **What it tests:**
148: - Session creation with real sled database
149: - Session retrieval from disk
150: - Session state updates (marking as started)
151: - Persistence across process restarts
152: - Real database files on disk
153: 
154: **Real dependencies used:**
155: - Sled database (on-disk key-value store)
156: - Filesystem operations
157: - Process spawning
158: 
159: ### Config Parsing (`test_config_parsing.sh`)
160: 
161: **What it tests:**
162: - Environment variable parsing
163: - Required field validation
164: - Default value application
165: - CSV parsing with whitespace
166: - Empty string filtering
167: 
168: **Real dependencies used:**
169: - Real environment variables
170: - Shell process environment
171: 
172: ### Claude JSON Parsing (`test_claude_json_parsing.sh`)
173: 
174: **What it tests:**
175: - Multi-block text responses
176: - Single block responses
177: - Empty content arrays
178: - Mixed content types (filtering non-text)
179: - Invalid JSON rejection
180: - Multiline responses
181: - Unicode character handling
182: 
183: **Real dependencies used:**
184: - Real JSON samples from Claude API
185: - serde_json parser
186: 
187: ### File Operations (`test_file_operations.sh`)
188: 
189: **What it tests:**
190: - Sled database directory creation
191: - File writing and persistence
192: - Read/write consistency
193: - Multiple rooms in same database
194: - Directory permissions
195: - Concurrent database access
196: 
197: **Real dependencies used:**
198: - Real filesystem
199: - Real sled database
200: - Real concurrent processes
201: 
202: ### CLI Args Generation (`test_cli_args_generation.sh`)
203: 
204: **What it tests:**
205: - First message args (`--session-id <uuid>`)
206: - Continuation args (`--resume <uuid>`)
207: - Command line construction
208: - Different rooms have different session IDs
209: 
210: **Real dependencies used:**
211: - Real session store
212: - Real command line construction
213: 
214: ## Debugging Tests
215: 
216: ### Enable verbose logging:
217: ```bash
218: RUST_LOG=debug cargo test -- --nocapture
219: ```
220: 
221: ### Run single test with backtrace:
222: ```bash
223: RUST_BACKTRACE=1 cargo test session_create_and_load
224: ```
225: 
226: ### Inspect scenario test intermediate files:
227: Scenario tests create temporary directories. To inspect:
228: 1. Edit scenario script
229: 2. Comment out `rm -rf "$TEST_DIR"` in cleanup function
230: 3. Run test
231: 4. Inspect files in printed temp directory
232: 
233: ## Continuous Integration
234: 
235: All tests should pass before merging:
236: 
237: ```bash
238: # Unit tests
239: cargo test
240: 
241: # Scenario tests
242: .scratch/run_all_scenarios.sh
243: 
244: # Linting
245: cargo clippy
246: 
247: # Formatting
248: cargo fmt --check
249: ```
250: 
251: ## Test Coverage
252: 
253: Current coverage areas:
254: - ‚úÖ Configuration parsing and validation
255: - ‚úÖ Session persistence with sled
256: - ‚úÖ Claude JSON response parsing
257: - ‚úÖ File I/O and directory operations
258: - ‚úÖ CLI argument generation
259: - ‚úÖ Multi-room session isolation
260: - ‚ö†Ô∏è  Matrix client initialization (manual only)
261: - ‚ö†Ô∏è  E2E encryption (manual only)
262: - ‚ö†Ô∏è  Message handling flow (manual only)
263: 
264: ## Adding New Tests
265: 
266: ### Unit Test
267: 1. Create test in `tests/` directory
268: 2. Follow TDD: write test first, see it fail, implement, see it pass
269: 3. Test one specific behavior
270: 4. Use standard Rust test framework
271: 
272: ### Scenario Test
273: 1. Create bash script in `.scratch/`
274: 2. Use REAL dependencies (no mocks)
275: 3. Verify observable outcomes
276: 4. Clean up resources in trap
277: 5. Make script executable
278: 6. Add to `run_all_scenarios.sh`
279: 
280: **Example scenario test structure:**
281: ```bash
282: #!/bin/bash
283: set -euo pipefail
284: 
285: TEST_DIR=$(mktemp -d)
286: cleanup() { rm -rf "$TEST_DIR"; }
287: trap cleanup EXIT
288: 
289: # Test with real dependencies
290: # Verify observable outcomes
291: # Exit 0 on success, 1 on failure
292: ```
293: 
294: ## Troubleshooting
295: 
296: **Tests fail with sled errors:**
297: - Ensure `/tmp` has write permissions
298: - Check disk space
299: - Clean old test databases: `cargo clean`
300: 
301: **Scenario tests fail to compile:**
302: - Tests fallback to `cargo test` automatically
303: - Check that `cargo build --release` succeeds first
304: 
305: **Unit tests pass but integration fails:**
306: - Check `.env` configuration
307: - Verify Matrix credentials
308: - Ensure Claude CLI is authenticated: `claude auth status`
309: 
310: ## Philosophy
311: 
312: ### Why No Mocks?
313: 
314: **Mocks hide bugs.** When you mock a database, you test your mock, not your code. Scenario tests use real sled databases, real files, and real processes to catch integration issues that mocks would miss.
315: 
316: ### Scenario vs Unit
317: 
318: - **Unit tests**: Fast, focused, test logic in isolation
319: - **Scenario tests**: Realistic, catch integration bugs, verify real system behavior
320: - Both are necessary for confidence
321: 
322: ### Observable Outcomes
323: 
324: Tests verify what the system actually does (files created, data persisted, processes spawned) rather than internal state. This catches real-world bugs.
325: 
326: ## Resources
327: 
328: - [Cargo Test Documentation](https://doc.rust-lang.org/cargo/commands/cargo-test.html)
329: - [Sled Database](https://github.com/spacejam/sled)
330: - [Matrix SDK Testing](https://matrix-org.github.io/matrix-rust-sdk/)
331: - [Scenario Testing Philosophy](https://www.hillelwayne.com/post/cross-branch-testing/)
</file>

<file path="tests/claude_tests.rs">
 1: #[test]
 2: fn test_parse_claude_response_success() {
 3:     let json = r#"{
 4:         "content": [
 5:             {"type": "text", "text": "Hello, "},
 6:             {"type": "text", "text": "world!"}
 7:         ]
 8:     }"#;
 9:     let result = matrix_bridge::claude::parse_response(json).unwrap();
10:     assert_eq!(result, "Hello, world!");
11: }
12: #[test]
13: fn test_parse_claude_response_empty() {
14:     let json = r#"{"content": []}"#;
15:     let result = matrix_bridge::claude::parse_response(json).unwrap();
16:     assert_eq!(result, "");
17: }
18: #[test]
19: fn test_parse_claude_response_malformed() {
20:     let json = "not valid json";
21:     let result = matrix_bridge::claude::parse_response(json);
22:     assert!(result.is_err());
23: }
</file>

<file path="tests/config_tests.rs">
 1: #[test]
 2: fn test_config_loads_from_env() {
 3:     std::env::set_var("MATRIX_HOME_SERVER", "https://test.com");
 4:     std::env::set_var("MATRIX_USER_ID", "@bot:test.com");
 5:     std::env::set_var("MATRIX_ROOM_ID", "!room:test.com");
 6:     std::env::set_var("MATRIX_PASSWORD", "secret");
 7:     std::env::set_var("ALLOWED_USERS", "@user1:test.com,@user2:test.com");
 8:     let config = matrix_bridge::config::Config::from_env().unwrap();
 9:     assert_eq!(config.matrix_home_server, "https://test.com");
10:     assert_eq!(config.matrix_user_id, "@bot:test.com");
11:     assert_eq!(config.matrix_room_id, "!room:test.com");
12:     assert_eq!(config.matrix_password, Some("secret".to_string()));
13:     assert_eq!(config.allowed_users.len(), 2);
14:     assert!(config.allowed_users.contains("@user1:test.com"));
15: }
16: #[test]
17: fn test_config_fails_on_missing_required_field() {
18:     std::env::remove_var("MATRIX_HOME_SERVER");
19:     std::env::remove_var("MATRIX_USER_ID");
20:     let result = matrix_bridge::config::Config::from_env();
21:     assert!(result.is_err());
22: }
</file>

<file path="tests/session_tests.rs">
 1: #[test]
 2: fn test_session_create_and_load() {
 3:     let temp_dir = std::env::temp_dir().join("matrix-bridge-test-sessions");
 4:     let _ = std::fs::remove_dir_all(&temp_dir);
 5:     let store = matrix_bridge::session::SessionStore::new(&temp_dir).unwrap();
 6:     let room_id = "!test:example.com";
 7:     // First load creates new session
 8:     let session1 = store.get_or_create(room_id).unwrap();
 9:     assert!(!session1.started);
10:     // Mark as started and save
11:     store.mark_started(room_id).unwrap();
12:     // Second load returns same session, marked as started
13:     let session2 = store.get_or_create(room_id).unwrap();
14:     assert_eq!(session1.session_id, session2.session_id);
15:     assert!(session2.started);
16:     // Cleanup
17:     std::fs::remove_dir_all(&temp_dir).unwrap();
18: }
19: #[test]
20: fn test_session_cli_args_first_message() {
21:     let session = matrix_bridge::session::Session {
22:         session_id: "test-uuid".to_string(),
23:         started: false,
24:     };
25:     let args = session.cli_args();
26:     assert_eq!(args, vec!["--session-id", "test-uuid"]);
27: }
28: #[test]
29: fn test_session_cli_args_continuation() {
30:     let session = matrix_bridge::session::Session {
31:         session_id: "test-uuid".to_string(),
32:         started: true,
33:     };
34:     let args = session.cli_args();
35:     assert_eq!(args, vec!["--resume", "test-uuid"]);
36: }
</file>

<file path=".env.example">
 1: # Matrix Settings
 2: MATRIX_HOME_SERVER=https://matrix.example.com
 3: MATRIX_USER_ID=@bot:example.com
 4: MATRIX_ROOM_ID=!abc123:example.com
 5: MATRIX_PASSWORD=your_password_here
 6: # MATRIX_ACCESS_TOKEN=optional_token_instead_of_password
 7: MATRIX_DEVICE_NAME=claude-matrix-bridge
 8: 
 9: # Access Control
10: ALLOWED_USERS=@you:example.com,@friend:example.com
11: 
12: # Claude Settings
13: CLAUDE_BINARY_PATH=claude
14: # CLAUDE_SDK_URL=http://localhost:8080
15: 
16: # Logging
17: RUST_LOG=info
</file>

<file path="config.toml.example">
 1: # Matrix-Claude Bridge Configuration
 2: 
 3: [matrix]
 4: # Matrix homeserver URL (required)
 5: home_server = "https://matrix.org"
 6: 
 7: # Full Matrix user ID for the bot (required)
 8: user_id = "@bot:matrix.org"
 9: 
10: # Matrix password (optional if access_token is provided)
11: password = "your-password-here"
12: 
13: # Matrix access token (optional if password is provided)
14: # access_token = "syt_..."
15: 
16: # Device name for this bot instance
17: device_name = "claude-matrix-bridge"
18: 
19: # Comma-separated list of allowed user IDs (required)
20: allowed_users = ["@user1:matrix.org", "@user2:matrix.org"]
21: 
22: # Prefix for room names (default: "Claude")
23: # Room names will be formatted as "PREFIX: channel-name"
24: # Example: "Work: PA" or "Personal: dev-help"
25: room_prefix = "Claude"
26: 
27: [claude]
28: # Path to the Claude binary (default: "claude")
29: binary_path = "claude"
30: 
31: # Optional: Custom Claude SDK URL
32: # sdk_url = "https://your-custom-sdk.com"
33: 
34: [webhook]
35: # Port for the webhook HTTP server (default: 3000)
36: port = 3000
37: 
38: # Host for webhook URLs (default: "localhost")
39: # This is used when displaying webhook URLs to users
40: host = "localhost"
41: 
42: # Optional: API key for webhook authentication
43: # If set, all webhook requests must include this key
44: # api_key = "your-secret-key-here"
45: 
46: [workspace]
47: # Directory where channel workspaces are stored (default: "./workspace")
48: path = "./workspace"
</file>

<file path=".github/workflows/ci.yml">
 1: # ABOUTME: GitHub Actions CI workflow for format checks, clippy linting, and test execution
 2: # ABOUTME: Runs on all pushes and pull requests with aggressive Cargo.lock-based caching
 3: name: CI
 4: on:
 5:   push:
 6:     branches: [ "*" ]
 7:   pull_request:
 8:     branches: [ "*" ]
 9: jobs:
10:   format:
11:     name: Format Check
12:     runs-on: ubuntu-latest
13:     steps:
14:       - name: Checkout code
15:         uses: actions/checkout@v4
16:       - name: Install Rust stable
17:         uses: dtolnay/rust-toolchain@stable
18:         with:
19:           components: rustfmt
20:       - name: Cache cargo registry
21:         uses: actions/cache@v4
22:         with:
23:           path: |
24:             ~/.cargo/bin/
25:             ~/.cargo/registry/index/
26:             ~/.cargo/registry/cache/
27:             ~/.cargo/git/db/
28:           key: rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
29:           restore-keys: |
30:             rust-cache-${{ runner.os }}-
31:       - name: Run rustfmt check
32:         run: cargo fmt --all -- --check
33:   clippy:
34:     name: Clippy Lint
35:     runs-on: ubuntu-latest
36:     steps:
37:       - name: Checkout code
38:         uses: actions/checkout@v4
39:       - name: Install Rust stable
40:         uses: dtolnay/rust-toolchain@stable
41:         with:
42:           components: clippy
43:       - name: Cache cargo registry
44:         uses: actions/cache@v4
45:         with:
46:           path: |
47:             ~/.cargo/bin/
48:             ~/.cargo/registry/index/
49:             ~/.cargo/registry/cache/
50:             ~/.cargo/git/db/
51:             target/
52:           key: rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
53:           restore-keys: |
54:             rust-cache-${{ runner.os }}-
55:       - name: Run clippy
56:         run: cargo clippy --all-targets --all-features -- -D warnings
57:   test:
58:     name: Test Suite
59:     runs-on: ubuntu-latest
60:     steps:
61:       - name: Checkout code
62:         uses: actions/checkout@v4
63:       - name: Install Rust stable
64:         uses: dtolnay/rust-toolchain@stable
65:       - name: Cache cargo registry
66:         uses: actions/cache@v4
67:         with:
68:           path: |
69:             ~/.cargo/bin/
70:             ~/.cargo/registry/index/
71:             ~/.cargo/registry/cache/
72:             ~/.cargo/git/db/
73:             target/
74:           key: rust-cache-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}
75:           restore-keys: |
76:             rust-cache-${{ runner.os }}-
77:       - name: Run tests
78:         run: cargo test --all-features
</file>

<file path="src/session.rs">
  1: // ABOUTME: Persistent session storage for Matrix room conversations using SQLite database.
  2: // ABOUTME: Maps channel names to Claude sessions backed by workspace directories.
  3: use anyhow::{Context, Result};
  4: use rusqlite::{params, Connection};
  5: use serde::{Deserialize, Serialize};
  6: use std::path::{Path, PathBuf};
  7: use std::sync::{Arc, Mutex};
  8: /// Recursively copy all contents from source directory to destination
  9: fn copy_dir_contents(src: &Path, dst: &Path) -> Result<()> {
 10:     for entry in std::fs::read_dir(src).context("Failed to read template directory")? {
 11:         let entry = entry.context("Failed to read directory entry")?;
 12:         let file_type = entry.file_type().context("Failed to get file type")?;
 13:         let src_path = entry.path();
 14:         let file_name = entry.file_name();
 15:         let dst_path = dst.join(&file_name);
 16:         if file_type.is_dir() {
 17:             std::fs::create_dir_all(&dst_path)
 18:                 .with_context(|| format!("Failed to create directory: {}", dst_path.display()))?;
 19:             copy_dir_contents(&src_path, &dst_path)?;
 20:         } else {
 21:             std::fs::copy(&src_path, &dst_path).with_context(|| {
 22:                 format!(
 23:                     "Failed to copy file from {} to {}",
 24:                     src_path.display(),
 25:                     dst_path.display()
 26:                 )
 27:             })?;
 28:         }
 29:     }
 30:     Ok(())
 31: }
 32: #[derive(Debug, Clone, Serialize, Deserialize)]
 33: pub struct Channel {
 34:     pub channel_name: String,
 35:     pub room_id: String,
 36:     pub session_id: String,
 37:     pub directory: String,
 38:     pub started: bool,
 39:     pub created_at: String,
 40: }
 41: impl Channel {
 42:     pub fn cli_args(&self) -> Vec<&str> {
 43:         if self.started {
 44:             vec!["--resume", &self.session_id]
 45:         } else {
 46:             vec!["--session-id", &self.session_id]
 47:         }
 48:     }
 49: }
 50: #[derive(Clone)]
 51: pub struct SessionStore {
 52:     db: Arc<Mutex<Connection>>,
 53:     workspace_path: PathBuf,
 54: }
 55: impl SessionStore {
 56:     pub fn new<P: AsRef<Path>>(workspace_path: P) -> Result<Self> {
 57:         let workspace_path = workspace_path.as_ref().to_path_buf();
 58:         // Create workspace directory if it doesn't exist
 59:         std::fs::create_dir_all(&workspace_path).context("Failed to create workspace directory")?;
 60:         let db_path = workspace_path.join("sessions.db");
 61:         let conn = Connection::open(&db_path).context("Failed to open SQLite database")?;
 62:         // Create channels table
 63:         conn.execute(
 64:             "CREATE TABLE IF NOT EXISTS channels (
 65:                 channel_name TEXT PRIMARY KEY,
 66:                 room_id TEXT NOT NULL UNIQUE,
 67:                 session_id TEXT NOT NULL,
 68:                 directory TEXT NOT NULL,
 69:                 started INTEGER NOT NULL DEFAULT 0,
 70:                 created_at TEXT NOT NULL
 71:             )",
 72:             [],
 73:         )?;
 74:         tracing::info!(
 75:             workspace = %workspace_path.display(),
 76:             db = %db_path.display(),
 77:             "SessionStore initialized"
 78:         );
 79:         Ok(SessionStore {
 80:             db: Arc::new(Mutex::new(conn)),
 81:             workspace_path,
 82:         })
 83:     }
 84:     /// Get channel by room ID
 85:     pub fn get_by_room(&self, room_id: &str) -> Result<Option<Channel>> {
 86:         let db = self.db.lock().unwrap();
 87:         let mut stmt = db.prepare(
 88:             "SELECT channel_name, room_id, session_id, directory, started, created_at
 89:              FROM channels WHERE room_id = ?1",
 90:         )?;
 91:         let channel = stmt.query_row(params![room_id], |row| {
 92:             Ok(Channel {
 93:                 channel_name: row.get(0)?,
 94:                 room_id: row.get(1)?,
 95:                 session_id: row.get(2)?,
 96:                 directory: row.get(3)?,
 97:                 started: row.get::<_, i32>(4)? != 0,
 98:                 created_at: row.get(5)?,
 99:             })
100:         });
101:         match channel {
102:             Ok(c) => Ok(Some(c)),
103:             Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
104:             Err(e) => Err(e.into()),
105:         }
106:     }
107:     /// Get channel by name
108:     pub fn get_by_name(&self, channel_name: &str) -> Result<Option<Channel>> {
109:         let db = self.db.lock().unwrap();
110:         let mut stmt = db.prepare(
111:             "SELECT channel_name, room_id, session_id, directory, started, created_at
112:              FROM channels WHERE channel_name = ?1",
113:         )?;
114:         let channel = stmt.query_row(params![channel_name], |row| {
115:             Ok(Channel {
116:                 channel_name: row.get(0)?,
117:                 room_id: row.get(1)?,
118:                 session_id: row.get(2)?,
119:                 directory: row.get(3)?,
120:                 started: row.get::<_, i32>(4)? != 0,
121:                 created_at: row.get(5)?,
122:             })
123:         });
124:         match channel {
125:             Ok(c) => Ok(Some(c)),
126:             Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
127:             Err(e) => Err(e.into()),
128:         }
129:     }
130:     /// Create a new channel with auto-generated session ID and directory
131:     pub fn create_channel(&self, channel_name: &str, room_id: &str) -> Result<Channel> {
132:         // Validate channel_name
133:         if !channel_name
134:             .chars()
135:             .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
136:         {
137:             anyhow::bail!("Invalid channel name: must be alphanumeric with dashes/underscores");
138:         }
139:         if channel_name.is_empty() || channel_name.len() > 64 {
140:             anyhow::bail!("Channel name must be 1-64 characters");
141:         }
142:         if channel_name.starts_with('.') || channel_name.starts_with('-') {
143:             anyhow::bail!("Channel name cannot start with . or -");
144:         }
145:         let channel_dir = self.workspace_path.join(channel_name);
146:         let channel = Channel {
147:             channel_name: channel_name.to_string(),
148:             room_id: room_id.to_string(),
149:             session_id: uuid::Uuid::new_v4().to_string(),
150:             directory: channel_dir.to_string_lossy().to_string(),
151:             started: false,
152:             created_at: chrono::Utc::now().to_rfc3339(),
153:         };
154:         // Try database insert first (prevents race condition)
155:         let db = self
156:             .db
157:             .lock()
158:             .map_err(|e| anyhow::anyhow!("Database lock poisoned: {}", e))?;
159:         match db.execute(
160:             "INSERT INTO channels (channel_name, room_id, session_id, directory, started, created_at)
161:              VALUES (?1, ?2, ?3, ?4, ?5, ?6)",
162:             params![
163:                 &channel.channel_name,
164:                 &channel.room_id,
165:                 &channel.session_id,
166:                 &channel.directory,
167:                 if channel.started { 1 } else { 0 },
168:                 &channel.created_at,
169:             ],
170:         ) {
171:             Ok(_) => {
172:                 // Release lock before file I/O
173:                 drop(db);
174:                 // Create directory only after successful DB insert
175:                 std::fs::create_dir_all(&channel_dir)
176:                     .context("Failed to create channel directory")?;
177:                 // Copy template directory if it exists
178:                 let template_dir = self.workspace_path.join("template");
179:                 if template_dir.exists() && template_dir.is_dir() {
180:                     copy_dir_contents(&template_dir, &channel_dir)
181:                         .context("Failed to copy template directory contents")?;
182:                     tracing::info!(
183:                         template = %template_dir.display(),
184:                         destination = %channel_dir.display(),
185:                         "Copied template to new channel"
186:                     );
187:                 }
188:                 tracing::info!(
189:                     channel_name = %channel_name,
190:                     room_id = %room_id,
191:                     session_id = %channel.session_id,
192:                     directory = %channel.directory,
193:                     "Channel created"
194:                 );
195:                 Ok(channel)
196:             }
197:             Err(e) => {
198:                 if let rusqlite::Error::SqliteFailure(sqlite_err, _) = &e {
199:                     if sqlite_err.code == rusqlite::ErrorCode::ConstraintViolation {
200:                         anyhow::bail!("Channel name or room already exists");
201:                     }
202:                 }
203:                 Err(e.into())
204:             }
205:         }
206:     }
207:     /// List all channels
208:     pub fn list_all(&self) -> Result<Vec<Channel>> {
209:         let db = self.db.lock().unwrap();
210:         let mut stmt = db.prepare(
211:             "SELECT channel_name, room_id, session_id, directory, started, created_at
212:              FROM channels ORDER BY created_at DESC",
213:         )?;
214:         let channels = stmt
215:             .query_map([], |row| {
216:                 Ok(Channel {
217:                     channel_name: row.get(0)?,
218:                     room_id: row.get(1)?,
219:                     session_id: row.get(2)?,
220:                     directory: row.get(3)?,
221:                     started: row.get::<_, i32>(4)? != 0,
222:                     created_at: row.get(5)?,
223:                 })
224:             })?
225:             .collect::<Result<Vec<_>, _>>()?;
226:         Ok(channels)
227:     }
228:     /// Delete a channel by name
229:     pub fn delete_channel(&self, channel_name: &str) -> Result<()> {
230:         let db = self.db.lock().unwrap();
231:         db.execute(
232:             "DELETE FROM channels WHERE channel_name = ?1",
233:             params![channel_name],
234:         )?;
235:         tracing::info!(channel_name = %channel_name, "Channel deleted");
236:         Ok(())
237:     }
238:     /// Mark channel as started
239:     pub fn mark_started(&self, room_id: &str) -> Result<()> {
240:         let db = self.db.lock().unwrap();
241:         db.execute(
242:             "UPDATE channels SET started = 1 WHERE room_id = ?1",
243:             params![room_id],
244:         )?;
245:         Ok(())
246:     }
247:     /// Get channel by session ID (for webhook lookups)
248:     pub fn get_by_session_id(&self, session_id: &str) -> Result<Option<Channel>> {
249:         let db = self.db.lock().unwrap();
250:         let mut stmt = db.prepare(
251:             "SELECT channel_name, room_id, session_id, directory, started, created_at
252:              FROM channels WHERE session_id = ?1",
253:         )?;
254:         let channel = stmt.query_row(params![session_id], |row| {
255:             Ok(Channel {
256:                 channel_name: row.get(0)?,
257:                 room_id: row.get(1)?,
258:                 session_id: row.get(2)?,
259:                 directory: row.get(3)?,
260:                 started: row.get::<_, i32>(4)? != 0,
261:                 created_at: row.get(5)?,
262:             })
263:         });
264:         match channel {
265:             Ok(c) => Ok(Some(c)),
266:             Err(rusqlite::Error::QueryReturnedNoRows) => Ok(None),
267:             Err(e) => Err(e.into()),
268:         }
269:     }
270: }
</file>

<file path="Cargo.toml">
 1: [package]
 2: name = "matrix-bridge"
 3: version = "0.1.0"
 4: edition = "2021"
 5: 
 6: [dependencies]
 7: tokio = { version = "1", features = ["full"] }
 8: matrix-sdk = { version = "0.7", features = ["e2e-encryption"] }
 9: rusqlite = { version = "0.30", features = ["bundled"] }
10: tracing = "0.1"
11: tracing-subscriber = { version = "0.3", features = ["env-filter"] }
12: dotenvy = "0.15"
13: serde = { version = "1.0", features = ["derive"] }
14: serde_json = "1.0"
15: toml = "0.8"
16: anyhow = "1.0"
17: uuid = { version = "1.6", features = ["v4"] }
18: futures-util = "0.3"
19: chrono = "0.4"
20: axum = "0.7"
21: tower = "0.5"
22: tower-http = { version = "0.6", features = ["trace"] }
</file>

<file path="src/matrix_client.rs">
  1: // ABOUTME: Matrix client initialization and authentication
  2: // ABOUTME: Handles client creation with crypto store and login via password or token
  3: use anyhow::{Context, Result};
  4: use matrix_sdk::{
  5:     ruma::{
  6:         api::client::room::create_room::v3::Request as CreateRoomRequest, assign, OwnedRoomId,
  7:         OwnedUserId,
  8:     },
  9:     Client,
 10: };
 11: use std::path::Path;
 12: pub async fn create_client(homeserver: &str, _user_id: &str) -> Result<Client> {
 13:     let client = Client::builder()
 14:         .homeserver_url(homeserver)
 15:         .sqlite_store(Path::new("./crypto_store"), None)
 16:         .build()
 17:         .await
 18:         .context("Failed to create Matrix client")?;
 19:     tracing::info!("Matrix client created successfully");
 20:     Ok(client)
 21: }
 22: pub async fn login(
 23:     client: &Client,
 24:     user_id: &str,
 25:     password: Option<&str>,
 26:     access_token: Option<&str>,
 27:     device_name: &str,
 28: ) -> Result<()> {
 29:     if let Some(token) = access_token {
 30:         tracing::info!("Logging in with access token");
 31:         let user_id: OwnedUserId = user_id.parse()?;
 32:         let session = matrix_sdk::AuthSession::Matrix(matrix_sdk::matrix_auth::MatrixSession {
 33:             meta: matrix_sdk::SessionMeta {
 34:                 user_id,
 35:                 device_id: device_name.to_string().into(),
 36:             },
 37:             tokens: matrix_sdk::matrix_auth::MatrixSessionTokens {
 38:                 access_token: token.to_string(),
 39:                 refresh_token: None,
 40:             },
 41:         });
 42:         client.restore_session(session).await?;
 43:     } else if let Some(pwd) = password {
 44:         tracing::info!("Logging in with password");
 45:         client
 46:             .matrix_auth()
 47:             .login_username(user_id, pwd)
 48:             .device_id(device_name)
 49:             .send()
 50:             .await
 51:             .context("Failed to log in")?;
 52:     } else {
 53:         anyhow::bail!("Either MATRIX_PASSWORD or MATRIX_ACCESS_TOKEN is required");
 54:     }
 55:     if let Some(user_id) = client.user_id() {
 56:         tracing::info!(user_id = %user_id, "Logged in successfully");
 57:     } else {
 58:         tracing::warn!("Login succeeded but user_id not available");
 59:     }
 60:     Ok(())
 61: }
 62: /// Create a new private room and return its ID
 63: /// Note: Room will be unencrypted for easier testing. User can enable encryption manually if needed.
 64: pub async fn create_room(client: &Client, room_name: &str) -> Result<OwnedRoomId> {
 65:     tracing::info!(room_name, "Creating new private room");
 66:     let request = assign!(CreateRoomRequest::new(), {
 67:         name: Some(room_name.to_string()),
 68:         is_direct: true,
 69:         visibility: matrix_sdk::ruma::api::client::room::Visibility::Private,
 70:         preset: Some(matrix_sdk::ruma::api::client::room::create_room::v3::RoomPreset::TrustedPrivateChat),
 71:     });
 72:     let room = client
 73:         .create_room(request)
 74:         .await
 75:         .context("Failed to create room")?;
 76:     let room_id = room.room_id().to_owned();
 77:     tracing::info!(%room_id, "Room created successfully");
 78:     Ok(room_id)
 79: }
 80: /// Invite a user to a room
 81: pub async fn invite_user(client: &Client, room_id: &OwnedRoomId, user_id: &str) -> Result<()> {
 82:     tracing::info!(%room_id, user_id, "Inviting user to room");
 83:     let user_id_parsed: OwnedUserId = user_id.parse()?;
 84:     let room = client.get_room(room_id).context("Room not found")?;
 85:     room.invite_user_by_id(&user_id_parsed)
 86:         .await
 87:         .context("Failed to invite user")?;
 88:     tracing::info!(%room_id, user_id, "User invited successfully");
 89:     Ok(())
 90: }
 91: /// Request verification with a user
 92: pub async fn request_verification(_client: &Client, user_id: &str) -> Result<()> {
 93:     tracing::info!(
 94:         user_id,
 95:         "Requesting verification with user (automatic after sync)"
 96:     );
 97:     // In matrix-sdk 0.7, verification is typically initiated by the other user
 98:     // or happens automatically when they message us. We'll log that we're ready
 99:     // for verification but won't force it.
100:     tracing::info!(
101:         user_id,
102:         "Bot is ready to accept verification requests from this user"
103:     );
104:     Ok(())
105: }
</file>

<file path=".gitignore">
 1: /target
 2: .env
 3: config.toml
 4: crypto_store/
 5: sessions_db/
 6: workspace/
 7: !workspace/template/
 8: .scratch/
 9: *.swp
10: *.swo
11: *~
12: .DS_Store
13: test-accounts.txt
</file>

<file path="README.md">
  1: # Matrix-Claude Bridge
  2: 
  3: Rust bot that creates dedicated Claude Code channels via Matrix, each backed by persistent workspace directories and webhook automation support.
  4: 
  5: ## Features
  6: 
  7: - **Channel-Based Architecture**: Each channel = dedicated Matrix room + Claude session + workspace directory
  8: - **Smart Session Persistence**: Channels automatically reuse the same Claude conversation every time
  9: - **Webhook Integration**: External triggers (cron, CI/CD) can inject prompts into channels via HTTP
 10: - **E2E Encryption**: Full support for encrypted Matrix rooms
 11: - **Whitelist Auth**: Only respond to approved users
 12: - **Workspace Management**: Organized directory structure for all channels
 13: 
 14: ## Prerequisites
 15: 
 16: - Rust 1.70+ (`rustup` recommended)
 17: - Claude Code CLI installed and authenticated
 18: - Matrix account for the bot
 19: - Matrix room with E2E encryption enabled
 20: 
 21: ## Setup
 22: 
 23: ### 1. Configure
 24: 
 25: Create a `config.toml` file in the project root:
 26: 
 27: ```bash
 28: cp config.toml.example config.toml
 29: # Edit config.toml with your Matrix credentials
 30: ```
 31: 
 32: Example `config.toml`:
 33: 
 34: ```toml
 35: [matrix]
 36: home_server = "https://matrix.org"
 37: user_id = "@yourbot:matrix.org"
 38: password = "your-password"  # or use access_token
 39: device_name = "claude-matrix-bridge"
 40: allowed_users = ["@you:matrix.org"]
 41: 
 42: [claude]
 43: binary_path = "claude"
 44: 
 45: [webhook]
 46: port = 3000
 47: 
 48: [workspace]
 49: path = "./workspace"
 50: ```
 51: 
 52: ### 2. Build and Run
 53: 
 54: ```bash
 55: cargo build --release
 56: cargo run --release
 57: ```
 58: 
 59: ### 3. Verify Device (First Run Only)
 60: 
 61: The bot creates a new Matrix device on first login. Verify it from another client:
 62: 
 63: 1. Open Element ‚Üí Settings ‚Üí Security
 64: 2. Find the new "claude-matrix-bridge" device
 65: 3. Verify using emoji verification or cross-signing
 66: 
 67: ## Usage
 68: 
 69: ### Creating a Channel
 70: 
 71: 1. DM the bot: `!create PA` (creates a "PA" channel)
 72: 2. Bot creates:
 73:    - `workspace/PA/` directory
 74:    - Matrix room "Claude: PA"
 75:    - Persistent Claude session
 76: 3. Join the room and start chatting!
 77: 
 78: ### Channel Template (Optional)
 79: 
 80: Populate `workspace/template/` with files you want in every new channel:
 81: 
 82: ```bash
 83: workspace/template/
 84: ‚îú‚îÄ‚îÄ CLAUDE.md              # Project-specific instructions
 85: ‚îú‚îÄ‚îÄ .mcp-servers.json      # MCP server configs
 86: ‚îî‚îÄ‚îÄ .gitignore             # Channel gitignore
 87: ```
 88: 
 89: When you create a new channel, all template contents are automatically copied to the new channel's directory. Perfect for:
 90: - Standardized CLAUDE.md instructions
 91: - Pre-configured MCP servers
 92: - Project boilerplate files
 93: - Shared tooling configs
 94: 
 95: ### Channel Commands
 96: 
 97: **DM Commands (Orchestrator):**
 98: - `!create <name>` - Create a new channel
 99: - `!list` - Show all your channels
100: - `!help` - Show help
101: 
102: **Room Commands:**
103: - `!status` - Show channel info (includes webhook URL and session ID)
104: - `!help` - Show help
105: 
106: ### Webhook Integration
107: 
108: Each channel has a webhook for automation:
109: 
110: ```bash
111: # Example: Daily news at 5am
112: 0 5 * * * curl -X POST http://localhost:3000/webhook/session/<session-id> \
113:   -H "Content-Type: application/json" \
114:   -d '{"prompt": "send me today'\''s tech news"}'
115: ```
116: 
117: Get your session ID with `!status` in the channel room.
118: 
119: ## Configuration
120: 
121: Configuration is loaded from `config.toml` with optional environment variable overrides:
122: 
123: **Matrix Settings:**
124: - `matrix.home_server` (required) - Your Matrix homeserver URL
125: - `matrix.user_id` (required) - Bot's Matrix user ID
126: - `matrix.password` - Bot password (or use `access_token`)
127: - `matrix.access_token` - Bot access token (alternative to password)
128: - `matrix.device_name` - Device name (default: "claude-matrix-bridge")
129: - `matrix.allowed_users` - Array of authorized user IDs
130: 
131: **Claude Settings:**
132: - `claude.binary_path` - Path to claude binary (default: "claude")
133: - `claude.sdk_url` - Optional custom Claude SDK URL
134: 
135: **Webhook Settings:**
136: - `webhook.port` - HTTP server port (default: 3000)
137: 
138: **Workspace Settings:**
139: - `workspace.path` - Directory for channel workspaces (default: "./workspace")
140: 
141: Environment variables override config file values:
142: - `MATRIX_HOME_SERVER`, `MATRIX_USER_ID`, `MATRIX_PASSWORD`, etc.
143: 
144: ## Troubleshooting
145: 
146: **Bot doesn't respond:**
147: - Check logs for "Ignoring message from unauthorized user"
148: - Verify your user ID is in `ALLOWED_USERS`
149: - Confirm bot joined the correct room
150: 
151: **Decryption failures:**
152: - Verify the bot's device from another client
153: - Check `crypto_store/` exists and has correct permissions
154: 
155: **Claude errors:**
156: - Verify `claude` binary is in PATH or set `CLAUDE_BINARY_PATH`
157: - Check Claude CLI is authenticated: `claude auth status`
158: 
159: ## Architecture
160: 
161: ```
162: workspace/
163: ‚îú‚îÄ‚îÄ sessions.db          # SQLite: channel_name ‚Üî room_id ‚Üî session_id ‚Üî directory
164: ‚îú‚îÄ‚îÄ PA/                  # Channel workspace directories
165: ‚îú‚îÄ‚îÄ dev-help/
166: ‚îî‚îÄ‚îÄ news-bot/
167: ```
168: 
169: **Code Structure:**
170: - `src/config.rs` - TOML config loading with env var overrides
171: - `src/session.rs` - SQLite-backed channel management
172: - `src/webhook.rs` - HTTP server for external triggers
173: - `src/claude.rs` - CLI spawning and JSON parsing
174: - `src/matrix_client.rs` - Matrix login and crypto setup
175: - `src/message_handler.rs` - Auth checks, channel commands, orchestration
176: - `src/main.rs` - Entry point, sync loop, webhook server spawn
177: 
178: ## License
179: 
180: MIT
</file>

<file path="src/claude.rs">
  1: // ABOUTME: This module handles spawning the Claude CLI process and parsing its JSON responses.
  2: // ABOUTME: It provides parse_response() for extracting text from Claude's JSON output and invoke_claude() for process execution.
  3: use anyhow::{Context, Result};
  4: use serde::Deserialize;
  5: use tokio::process::Command;
  6: #[derive(Debug, Deserialize)]
  7: struct ClaudeResponse {
  8:     #[serde(default)]
  9:     result: Option<String>,
 10:     #[serde(default)]
 11:     subtype: Option<String>,
 12:     #[serde(default)]
 13:     is_error: bool,
 14:     #[serde(default)]
 15:     error: Option<String>,
 16:     #[serde(default)]
 17:     message: Option<String>,
 18: }
 19: pub fn parse_response(json: &str) -> Result<String> {
 20:     let response: ClaudeResponse =
 21:         serde_json::from_str(json).context("Failed to parse Claude JSON response")?;
 22:     // If there's a result field, return it
 23:     if let Some(result) = response.result {
 24:         return Ok(result);
 25:     }
 26:     // If no result but there's an error indicator, provide helpful message
 27:     if response.is_error {
 28:         let error_details = response
 29:             .error
 30:             .or(response.message)
 31:             .unwrap_or_else(|| "No error details provided".to_string());
 32:         anyhow::bail!(
 33:             "Claude reported an error (subtype: {}): {}",
 34:             response.subtype.unwrap_or_else(|| "unknown".to_string()),
 35:             error_details
 36:         );
 37:     }
 38:     // If no result field at all, show what we got
 39:     let error_details = response
 40:         .error
 41:         .or(response.message)
 42:         .unwrap_or_else(|| "No additional details".to_string());
 43:     anyhow::bail!(
 44:         "Claude response missing 'result' field (subtype: {}): {}",
 45:         response.subtype.unwrap_or_else(|| "unknown".to_string()),
 46:         error_details
 47:     );
 48: }
 49: pub async fn invoke_claude(
 50:     binary_path: &str,
 51:     sdk_url: Option<&str>,
 52:     session_args: Vec<&str>,
 53:     prompt: &str,
 54:     working_dir: Option<&str>,
 55: ) -> Result<String> {
 56:     // Validate binary path doesn't contain suspicious characters
 57:     if binary_path.contains("..") || binary_path.contains('\0') {
 58:         anyhow::bail!("Invalid claude binary path");
 59:     }
 60:     let mut args = vec!["--print", "--output-format", "json"];
 61:     args.extend(session_args);
 62:     if let Some(url) = sdk_url {
 63:         args.extend(["--sdk-url", url]);
 64:     }
 65:     args.push(prompt);
 66:     tracing::debug!(?args, working_dir, "Spawning Claude CLI");
 67:     let mut command = Command::new(binary_path);
 68:     command.args(&args);
 69:     // Set working directory if specified
 70:     if let Some(dir) = working_dir {
 71:         // Validate directory exists
 72:         if !std::path::Path::new(dir).exists() {
 73:             anyhow::bail!("Working directory does not exist: {}", dir);
 74:         }
 75:         command.current_dir(dir);
 76:         tracing::info!(working_dir = dir, "Running Claude in specified directory");
 77:     }
 78:     let output = command.output().await.with_context(|| {
 79:         if let Some(dir) = working_dir {
 80:             format!("Failed to spawn claude CLI in directory: {}", dir)
 81:         } else {
 82:             "Failed to spawn claude CLI".to_string()
 83:         }
 84:     })?;
 85:     if !output.status.success() {
 86:         let stderr = String::from_utf8_lossy(&output.stderr);
 87:         anyhow::bail!(
 88:             "Claude CLI failed with exit code {:?}: {}",
 89:             output.status.code(),
 90:             stderr
 91:         );
 92:     }
 93:     let stdout = String::from_utf8(output.stdout).context("Claude output is not valid UTF-8")?;
 94:     tracing::debug!(stdout_preview = %stdout.chars().take(500).collect::<String>(), "Claude raw output");
 95:     parse_response(&stdout).inspect_err(|e| {
 96:         tracing::error!(
 97:             error = %e,
 98:             stdout_sample = %stdout.chars().take(1000).collect::<String>(),
 99:             "Failed to parse Claude response"
100:         );
101:     })
102: }
</file>

<file path="src/message_handler.rs">
  1: // ABOUTME: Message handler that processes Matrix room messages with authentication and Claude invocation.
  2: // ABOUTME: Checks room ID and user whitelist, manages typing indicators, and handles Claude response delivery.
  3: use anyhow::Result;
  4: use matrix_sdk::{
  5:     room::Room, ruma::events::room::message::RoomMessageEventContent, Client, RoomState,
  6: };
  7: use crate::{claude, config::Config, matrix_client, session::SessionStore};
  8: pub async fn handle_message(
  9:     room: Room,
 10:     event: matrix_sdk::ruma::events::room::message::OriginalSyncRoomMessageEvent,
 11:     client: Client,
 12:     config: Config,
 13:     session_store: SessionStore,
 14: ) -> Result<()> {
 15:     // Only work with joined rooms
 16:     if room.state() != RoomState::Joined {
 17:         return Ok(());
 18:     }
 19:     // Check if this is a DM (direct message)
 20:     let is_dm = room.is_direct().await.unwrap_or(false);
 21:     let sender = event.sender.as_str();
 22:     let body = &event.content.body();
 23:     // Ignore bot's own messages
 24:     let Some(bot_user_id) = client.user_id() else {
 25:         tracing::warn!("Bot user_id not available, skipping message");
 26:         return Ok(());
 27:     };
 28:     if sender == bot_user_id.as_str() {
 29:         return Ok(());
 30:     }
 31:     // Check whitelist
 32:     let allowed_users = config.allowed_users_set();
 33:     if !allowed_users.contains(sender) {
 34:         tracing::debug!(sender, "Ignoring message from unauthorized user");
 35:         return Ok(());
 36:     }
 37:     // Safe preview generation (respects UTF-8 boundaries)
 38:     let message_preview: String = body.chars().take(50).collect();
 39:     tracing::info!(sender, room_id = %room.room_id(), message_preview, "Processing message");
 40:     // Handle commands - be specific about what constitutes a command
 41:     // Accept "!claude <command>" or "!<word>" (but not just "!" or "!!")
 42:     let is_command = body.starts_with("!claude ")
 43:         || (body.starts_with("!")
 44:             && body.len() > 1
 45:             && body.chars().nth(1).map_or(false, |c| c.is_alphabetic()));
 46:     if is_command {
 47:         return handle_command(room, body, &session_store, &client, sender, is_dm, &config).await;
 48:     }
 49:     // Check if channel is attached
 50:     let Some(channel) = session_store.get_by_room(room.room_id().as_str())? else {
 51:         let help_msg = if is_dm {
 52:             "üëã Welcome! To get started, create a channel:\n\n\
 53:             !create <channel-name>\n\n\
 54:             Example: !create PA\n\
 55:             This creates a dedicated Claude session in a workspace directory."
 56:         } else {
 57:             "No Claude channel attached to this room.\n\n\
 58:             üí° DM me to create a channel with: !create <name>\n\n\
 59:             Need help? Send: !help"
 60:         };
 61:         room.send(RoomMessageEventContent::text_plain(help_msg))
 62:             .await?;
 63:         return Ok(());
 64:     };
 65:     let channel_args = channel.cli_args();
 66:     // Start typing indicator and keep it alive
 67:     room.typing_notice(true).await?;
 68:     // Spawn a task to keep the typing indicator refreshed every 25 seconds
 69:     let typing_room = room.clone();
 70:     let (typing_tx, mut typing_rx) = tokio::sync::oneshot::channel();
 71:     let typing_handle = tokio::spawn(async move {
 72:         let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(25));
 73:         interval.tick().await; // Skip first immediate tick
 74:         loop {
 75:             tokio::select! {
 76:                 _ = interval.tick() => {
 77:                     if let Err(e) = typing_room.typing_notice(true).await {
 78:                         tracing::warn!(error = %e, "Failed to refresh typing indicator");
 79:                         break;
 80:                     }
 81:                 }
 82:                 _ = &mut typing_rx => {
 83:                     // Stop signal received
 84:                     break;
 85:                 }
 86:             }
 87:         }
 88:     });
 89:     // Invoke Claude
 90:     let response = match claude::invoke_claude(
 91:         &config.claude.binary_path,
 92:         config.claude.sdk_url.as_deref(),
 93:         channel_args,
 94:         body,
 95:         Some(&channel.directory),
 96:     )
 97:     .await
 98:     {
 99:         Ok(resp) => {
100:             tracing::info!(response_length = resp.len(), "Claude responded");
101:             resp
102:         }
103:         Err(e) => {
104:             tracing::error!(error = %e, "Claude invocation failed");
105:             let error_msg = format!("‚ö†Ô∏è Claude error: {}", e);
106:             // Stop typing indicator refresh
107:             let _ = typing_tx.send(());
108:             typing_handle.abort();
109:             room.typing_notice(false).await?;
110:             room.send(RoomMessageEventContent::text_plain(&error_msg))
111:                 .await?;
112:             return Ok(());
113:         }
114:     };
115:     // Mark session as started BEFORE sending response (to ensure consistency)
116:     session_store.mark_started(room.room_id().as_str())?;
117:     // Stop typing indicator refresh
118:     let _ = typing_tx.send(());
119:     let _ = typing_handle.await; // Wait for graceful shutdown
120:     room.typing_notice(false).await?;
121:     // Send response
122:     room.send(RoomMessageEventContent::text_plain(&response))
123:         .await?;
124:     tracing::info!("Response sent successfully");
125:     Ok(())
126: }
127: async fn handle_command(
128:     room: Room,
129:     body: &str,
130:     session_store: &SessionStore,
131:     client: &Client,
132:     sender: &str,
133:     is_dm: bool,
134:     config: &Config,
135: ) -> Result<()> {
136:     let parts: Vec<&str> = body.split_whitespace().collect();
137:     // Strip !claude prefix if present, otherwise treat whole thing as command
138:     let command_parts: Vec<&str> = if body.starts_with("!claude ") {
139:         parts[1..].to_vec()
140:     } else if body.starts_with("!") {
141:         let mut p = parts.clone();
142:         if let Some(first) = p.first_mut() {
143:             *first = &first[1..]; // Remove the ! prefix
144:         }
145:         p
146:     } else {
147:         parts.clone()
148:     };
149:     if command_parts.is_empty() || command_parts[0].is_empty() {
150:         let help_msg = if is_dm {
151:             "üí¨ Orchestrator Commands:\n\
152:             !create <name> - Create new channel (e.g., !create PA)\n\
153:             !list - Show all your channels\n\
154:             !help - Show detailed help"
155:         } else {
156:             "Available commands:\n\
157:             !help - Show detailed help\n\
158:             !status - Show current channel info"
159:         };
160:         room.send(RoomMessageEventContent::text_plain(help_msg))
161:             .await?;
162:         return Ok(());
163:     }
164:     let command = command_parts[0];
165:     match command {
166:         "help" => {
167:             let help_text = format!(
168:                 "üìö Claude Channel System Help\n\n\
169:                 ## What are Channels?\n\
170:                 Channels are persistent Claude conversations backed by workspace directories.\n\
171:                 Each channel has its own Matrix room, Claude session, and working directory.\n\n\
172:                 ## DM Commands (Orchestrator)\n\
173:                 !create <name> - Create a new channel\n\
174:                   Example: !create PA\n\
175:                   Creates: workspace/PA/ directory + Matrix room + Claude session\n\n\
176:                 !list - Show all your channels\n\
177:                 !help - Show this help message\n\n\
178:                 ## Room Commands\n\
179:                 !status - Show current channel info\n\
180:                 !help - Show this help message\n\n\
181:                 ## How It Works\n\
182:                 1. DM the bot: !create PA\n\
183:                 2. Bot creates:\n\
184:                    - workspace/PA/ directory\n\
185:                    - Matrix room named \"{}: PA\"\n\
186:                    - Persistent Claude session\n\
187:                 3. Join the room and start chatting!\n\
188:                 4. All conversation history is preserved\n\n\
189:                 ## Webhook Support\n\
190:                 Each channel has a webhook URL for external triggers:\n\
191:                   POST http://{}:{}/webhook/session/<session-id>\n\
192:                   {{\"prompt\": \"your message here\"}}\n\n\
193:                 Use this for scheduled tasks, cron jobs, etc.\n\n\
194:                 ## Features\n\
195:                 ‚úÖ Persistent conversation history\n\
196:                 ‚úÖ Dedicated workspace per channel\n\
197:                 ‚úÖ Smart session reuse\n\
198:                 ‚úÖ Webhook integration for automation\n\
199:                 ‚úÖ One channel = one ongoing conversation\n\n\
200:                 Need more help? Just ask!",
201:                 config.matrix.room_prefix, config.webhook.host, config.webhook.port
202:             );
203:             room.send(RoomMessageEventContent::text_plain(&help_text))
204:                 .await?;
205:         }
206:         "status" => {
207:             if let Some(channel) = session_store.get_by_room(room.room_id().as_str())? {
208:                 let status = format!(
209:                     "üìä Channel Status\n\n\
210:                     Channel: {}\n\
211:                     Session ID: {}\n\
212:                     Directory: {}\n\
213:                     Started: {}\n\n\
214:                     Webhook URL:\n\
215:                     POST http://{}:{}/webhook/session/{}\n\n\
216:                     This room is backed by a persistent Claude session.",
217:                     channel.channel_name,
218:                     channel.session_id,
219:                     channel.directory,
220:                     if channel.started {
221:                         "Yes"
222:                     } else {
223:                         "No (first message will start it)"
224:                     },
225:                     config.webhook.host,
226:                     config.webhook.port,
227:                     channel.session_id
228:                 );
229:                 room.send(RoomMessageEventContent::text_plain(&status))
230:                     .await?;
231:             } else {
232:                 room.send(RoomMessageEventContent::text_plain(
233:                     "üìä Channel Status\n\n\
234:                     No channel attached.\n\n\
235:                     DM me to create one: !create <name>",
236:                 ))
237:                 .await?;
238:             }
239:         }
240:         "create" => {
241:             if !is_dm {
242:                 room.send(RoomMessageEventContent::text_plain(
243:                     "‚ùå The !create command only works in DMs.\n\nDM me to create a new channel!",
244:                 ))
245:                 .await?;
246:                 return Ok(());
247:             }
248:             if command_parts.len() < 2 {
249:                 room.send(RoomMessageEventContent::text_plain(
250:                     "Usage: !create <channel-name>\n\n\
251:                     Example: !create PA\n\
252:                     Example: !create dev-help\n\n\
253:                     This will create a workspace directory and Matrix room for the channel.",
254:                 ))
255:                 .await?;
256:                 return Ok(());
257:             }
258:             let channel_name = command_parts[1].to_string();
259:             // Validate channel name (alphanumeric, dashes, underscores only)
260:             if !channel_name
261:                 .chars()
262:                 .all(|c| c.is_alphanumeric() || c == '-' || c == '_')
263:             {
264:                 room.send(RoomMessageEventContent::text_plain(
265:                     "‚ùå Channel name can only contain letters, numbers, dashes, and underscores.\n\n\
266:                     Example: PA, dev-help, my_channel",
267:                 ))
268:                 .await?;
269:                 return Ok(());
270:             }
271:             // Check if channel already exists
272:             if session_store.get_by_name(&channel_name)?.is_some() {
273:                 room.send(RoomMessageEventContent::text_plain(&format!(
274:                     "‚ùå Channel '{}' already exists.\n\nUse !list to see all channels.",
275:                     channel_name
276:                 )))
277:                 .await?;
278:                 return Ok(());
279:             }
280:             // Create Matrix room
281:             let room_name = format!("{}: {}", config.matrix.room_prefix, channel_name);
282:             let new_room_id = matrix_client::create_room(client, &room_name).await?;
283:             // Invite user
284:             matrix_client::invite_user(client, &new_room_id, sender).await?;
285:             // Create channel in database (this also creates the directory)
286:             let channel = session_store.create_channel(&channel_name, new_room_id.as_str())?;
287:             let response = format!(
288:                 "‚úÖ Created Channel: {}\n\n\
289:                 Room: {}\n\
290:                 Session ID: {}\n\
291:                 Directory: {}\n\n\
292:                 Check your room list - I've invited you!\n\
293:                 Once you join, just send messages to start working.\n\n\
294:                 Webhook: POST http://{}:{}/webhook/session/{}",
295:                 channel_name,
296:                 room_name,
297:                 &channel.session_id[..8],
298:                 channel.directory,
299:                 config.webhook.host,
300:                 config.webhook.port,
301:                 channel.session_id
302:             );
303:             room.send(RoomMessageEventContent::text_plain(&response))
304:                 .await?;
305:             tracing::info!(
306:                 room_id = %new_room_id,
307:                 channel_name = %channel_name,
308:                 session_id = %channel.session_id,
309:                 directory = %channel.directory,
310:                 user = %sender,
311:                 "Created channel for user"
312:             );
313:         }
314:         "list" => {
315:             let channels = session_store.list_all()?;
316:             if channels.is_empty() {
317:                 let msg = if is_dm {
318:                     "üìã No Channels Yet\n\nCreate one with: !create <name>\n\nExample: !create PA"
319:                 } else {
320:                     "üìã No Channels Found\n\nDM me to create a channel!"
321:                 };
322:                 room.send(RoomMessageEventContent::text_plain(msg)).await?;
323:                 return Ok(());
324:             }
325:             let mut list_text = String::from("üìã Your Claude Channels\n\n");
326:             for (idx, channel) in channels.iter().enumerate() {
327:                 let current_marker = if channel.room_id == room.room_id().as_str() {
328:                     " ‚Üê (current)"
329:                 } else {
330:                     ""
331:                 };
332:                 list_text.push_str(&format!(
333:                     "{}. {}{}\n   üìÅ {}\n   üîë Session: {}\n   Webhook: /webhook/session/{}\n\n",
334:                     idx + 1,
335:                     channel.channel_name,
336:                     current_marker,
337:                     channel.directory,
338:                     &channel.session_id[..8],
339:                     channel.session_id
340:                 ));
341:             }
342:             room.send(RoomMessageEventContent::text_plain(&list_text))
343:                 .await?;
344:         }
345:         _ => {
346:             let help_msg = if is_dm {
347:                 "Unknown command. Available commands:\n\
348:                 !create <name> - Create new channel\n\
349:                 !list - Show all channels\n\
350:                 !help - Show detailed help"
351:             } else {
352:                 "Unknown command. Available commands:\n\
353:                 !status - Show channel info\n\
354:                 !help - Show detailed help"
355:             };
356:             room.send(RoomMessageEventContent::text_plain(help_msg))
357:                 .await?;
358:         }
359:     }
360:     Ok(())
361: }
</file>

<file path="src/config.rs">
  1: // ABOUTME: Configuration parsing from TOML file with environment variable overrides
  2: // ABOUTME: Validates required fields and provides sensible defaults for optional ones
  3: use anyhow::{Context, Result};
  4: use serde::{Deserialize, Serialize};
  5: use std::collections::HashSet;
  6: use std::path::Path;
  7: #[derive(Debug, Clone, Serialize, Deserialize)]
  8: pub struct Config {
  9:     pub matrix: MatrixConfig,
 10:     pub claude: ClaudeConfig,
 11:     pub webhook: WebhookConfig,
 12:     pub workspace: WorkspaceConfig,
 13: }
 14: #[derive(Debug, Clone, Serialize, Deserialize)]
 15: pub struct MatrixConfig {
 16:     pub home_server: String,
 17:     pub user_id: String,
 18:     #[serde(skip_serializing_if = "Option::is_none")]
 19:     pub password: Option<String>,
 20:     #[serde(skip_serializing_if = "Option::is_none")]
 21:     pub access_token: Option<String>,
 22:     #[serde(default = "default_device_name")]
 23:     pub device_name: String,
 24:     pub allowed_users: Vec<String>,
 25:     #[serde(default = "default_room_prefix")]
 26:     pub room_prefix: String,
 27: }
 28: #[derive(Debug, Clone, Serialize, Deserialize)]
 29: pub struct ClaudeConfig {
 30:     #[serde(default = "default_claude_binary")]
 31:     pub binary_path: String,
 32:     #[serde(skip_serializing_if = "Option::is_none")]
 33:     pub sdk_url: Option<String>,
 34: }
 35: #[derive(Debug, Clone, Serialize, Deserialize)]
 36: pub struct WebhookConfig {
 37:     #[serde(default = "default_webhook_port")]
 38:     pub port: u16,
 39:     #[serde(skip_serializing_if = "Option::is_none")]
 40:     pub api_key: Option<String>,
 41:     #[serde(default = "default_webhook_host")]
 42:     pub host: String,
 43: }
 44: #[derive(Debug, Clone, Serialize, Deserialize)]
 45: pub struct WorkspaceConfig {
 46:     #[serde(default = "default_workspace_path")]
 47:     pub path: String,
 48: }
 49: fn default_device_name() -> String {
 50:     "claude-matrix-bridge".to_string()
 51: }
 52: fn default_claude_binary() -> String {
 53:     "claude".to_string()
 54: }
 55: fn default_webhook_port() -> u16 {
 56:     3000
 57: }
 58: fn default_webhook_host() -> String {
 59:     "localhost".to_string()
 60: }
 61: fn default_workspace_path() -> String {
 62:     "./workspace".to_string()
 63: }
 64: fn default_room_prefix() -> String {
 65:     "Claude".to_string()
 66: }
 67: impl Config {
 68:     /// Load configuration from config.toml with environment variable overrides
 69:     pub fn load() -> Result<Self> {
 70:         // Try to load from config.toml first
 71:         let config_path = "config.toml";
 72:         let mut config = if Path::new(config_path).exists() {
 73:             let content =
 74:                 std::fs::read_to_string(config_path).context("Failed to read config.toml")?;
 75:             toml::from_str::<Config>(&content).context("Failed to parse config.toml")?
 76:         } else {
 77:             // If no config file, create default config
 78:             Config {
 79:                 matrix: MatrixConfig {
 80:                     home_server: String::new(),
 81:                     user_id: String::new(),
 82:                     password: None,
 83:                     access_token: None,
 84:                     device_name: default_device_name(),
 85:                     allowed_users: Vec::new(),
 86:                     room_prefix: default_room_prefix(),
 87:                 },
 88:                 claude: ClaudeConfig {
 89:                     binary_path: default_claude_binary(),
 90:                     sdk_url: None,
 91:                 },
 92:                 webhook: WebhookConfig {
 93:                     port: default_webhook_port(),
 94:                     api_key: None,
 95:                     host: default_webhook_host(),
 96:                 },
 97:                 workspace: WorkspaceConfig {
 98:                     path: default_workspace_path(),
 99:                 },
100:             }
101:         };
102:         // Override with environment variables if present
103:         if let Ok(val) = std::env::var("MATRIX_HOME_SERVER") {
104:             config.matrix.home_server = val;
105:         }
106:         if let Ok(val) = std::env::var("MATRIX_USER_ID") {
107:             config.matrix.user_id = val;
108:         }
109:         if let Ok(val) = std::env::var("MATRIX_PASSWORD") {
110:             config.matrix.password = Some(val);
111:         }
112:         if let Ok(val) = std::env::var("MATRIX_ACCESS_TOKEN") {
113:             config.matrix.access_token = Some(val);
114:         }
115:         if let Ok(val) = std::env::var("MATRIX_DEVICE_NAME") {
116:             config.matrix.device_name = val;
117:         }
118:         if let Ok(val) = std::env::var("ALLOWED_USERS") {
119:             config.matrix.allowed_users = val
120:                 .split(',')
121:                 .map(|s| s.trim().to_string())
122:                 .filter(|s| !s.is_empty())
123:                 .collect();
124:         }
125:         if let Ok(val) = std::env::var("MATRIX_ROOM_PREFIX") {
126:             config.matrix.room_prefix = val;
127:         }
128:         if let Ok(val) = std::env::var("CLAUDE_BINARY_PATH") {
129:             config.claude.binary_path = val;
130:         }
131:         if let Ok(val) = std::env::var("CLAUDE_SDK_URL") {
132:             config.claude.sdk_url = Some(val);
133:         }
134:         if let Ok(val) = std::env::var("WEBHOOK_PORT") {
135:             config.webhook.port = val.parse().with_context(|| {
136:                 format!("WEBHOOK_PORT must be a valid port number, got: {}", val)
137:             })?;
138:         }
139:         if let Ok(val) = std::env::var("WEBHOOK_API_KEY") {
140:             config.webhook.api_key = Some(val);
141:         }
142:         if let Ok(val) = std::env::var("WEBHOOK_HOST") {
143:             config.webhook.host = val;
144:         }
145:         if let Ok(val) = std::env::var("WORKSPACE_PATH") {
146:             config.workspace.path = val;
147:         }
148:         // Validate required fields
149:         if config.matrix.home_server.trim().is_empty() {
150:             anyhow::bail!(
151:                 "matrix.home_server is required (set in config.toml or MATRIX_HOME_SERVER env var)"
152:             );
153:         }
154:         if config.matrix.user_id.trim().is_empty() {
155:             anyhow::bail!(
156:                 "matrix.user_id is required (set in config.toml or MATRIX_USER_ID env var)"
157:             );
158:         }
159:         if config.matrix.password.is_none() && config.matrix.access_token.is_none() {
160:             anyhow::bail!("Either matrix.password or matrix.access_token is required");
161:         }
162:         // Clean and validate allowed_users
163:         config.matrix.allowed_users.retain(|s| !s.trim().is_empty());
164:         if config.matrix.allowed_users.is_empty() {
165:             anyhow::bail!("matrix.allowed_users must contain at least one user ID");
166:         }
167:         for user in &config.matrix.allowed_users {
168:             if !user.starts_with('@') || !user.contains(':') {
169:                 anyhow::bail!("Invalid Matrix user ID in allowed_users: {}", user);
170:             }
171:         }
172:         Ok(config)
173:     }
174:     /// Convert allowed_users Vec to HashSet for efficient lookups
175:     pub fn allowed_users_set(&self) -> HashSet<String> {
176:         self.matrix.allowed_users.iter().cloned().collect()
177:     }
178: }
</file>

<file path="src/main.rs">
  1: // ABOUTME: Main entry point for Matrix-Claude bridge with sync loop
  2: // ABOUTME: Initializes logging, config, session store, Matrix client, and message handlers
  3: use anyhow::Result;
  4: use futures_util::StreamExt;
  5: use matrix_bridge::{
  6:     config::Config, matrix_client, message_handler, session::SessionStore, webhook,
  7: };
  8: use matrix_sdk::{config::SyncSettings, ruma::events::room::message::SyncRoomMessageEvent, Client};
  9: use std::sync::Arc;
 10: use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
 11: #[tokio::main]
 12: async fn main() -> Result<()> {
 13:     // Initialize logging
 14:     tracing_subscriber::registry()
 15:         .with(
 16:             tracing_subscriber::EnvFilter::try_from_default_env().unwrap_or_else(|_| {
 17:                 // Default to info, but suppress backup and crypto warnings
 18:                 "info,matrix_sdk_crypto::backups=error,matrix_sdk_crypto::session_manager::sessions=error".into()
 19:             }),
 20:         )
 21:         .with(tracing_subscriber::fmt::layer())
 22:         .init();
 23:     tracing::info!("Starting Matrix-Claude Bridge");
 24:     // Load configuration
 25:     dotenvy::dotenv().ok();
 26:     let config = Config::load()?;
 27:     tracing::info!(
 28:         homeserver = %config.matrix.home_server,
 29:         user_id = %config.matrix.user_id,
 30:         allowed_users = config.matrix.allowed_users.len(),
 31:         workspace = %config.workspace.path,
 32:         webhook_port = config.webhook.port,
 33:         "Configuration loaded"
 34:     );
 35:     // Initialize session store
 36:     let session_store = SessionStore::new(&config.workspace.path)?;
 37:     tracing::info!(workspace = %config.workspace.path, "Session store initialized");
 38:     // Create Matrix client
 39:     let client =
 40:         matrix_client::create_client(&config.matrix.home_server, &config.matrix.user_id).await?;
 41:     // Login
 42:     matrix_client::login(
 43:         &client,
 44:         &config.matrix.user_id,
 45:         config.matrix.password.as_deref(),
 46:         config.matrix.access_token.as_deref(),
 47:         &config.matrix.device_name,
 48:     )
 49:     .await?;
 50:     tracing::info!("Bot ready - DM me to create Claude rooms!");
 51:     // Register message handler
 52:     let config_arc = Arc::new(config);
 53:     let session_store_arc = Arc::new(session_store);
 54:     // Clone Arcs for webhook server
 55:     let webhook_config = Arc::clone(&config_arc);
 56:     let webhook_session_store = Arc::clone(&session_store_arc);
 57:     client.add_event_handler(move |event: SyncRoomMessageEvent, room, client| {
 58:         let config = Arc::clone(&config_arc);
 59:         let session_store = Arc::clone(&session_store_arc);
 60:         async move {
 61:             // Extract original message event
 62:             let Some(original_event) = event.as_original() else {
 63:                 return;
 64:             };
 65:             if let Err(e) = message_handler::handle_message(
 66:                 room,
 67:                 original_event.clone(),
 68:                 client,
 69:                 (*config).clone(),
 70:                 (*session_store).clone(),
 71:             )
 72:             .await
 73:             {
 74:                 tracing::error!(error = %e, "Error handling message");
 75:             }
 76:         }
 77:     });
 78:     // Register verification event handler
 79:     client.add_event_handler(
 80:         |ev: matrix_sdk::ruma::events::key::verification::request::ToDeviceKeyVerificationRequestEvent,
 81:          client: Client| async move {
 82:             let request = client
 83:                 .encryption()
 84:                 .get_verification_request(&ev.sender, &ev.content.transaction_id)
 85:                 .await
 86:                 .expect("Request object must exist");
 87:             request
 88:                 .accept()
 89:                 .await
 90:                 .expect("Can't accept verification request");
 91:         },
 92:     );
 93:     // Register SAS verification handler (emoji verification)
 94:     client.add_event_handler(
 95:         |ev: matrix_sdk::ruma::events::key::verification::start::ToDeviceKeyVerificationStartEvent,
 96:          client: Client| async move {
 97:             if let Some(verification) = client
 98:                 .encryption()
 99:                 .get_verification(&ev.sender, ev.content.transaction_id.as_str())
100:                 .await
101:             {
102:                 if let matrix_sdk::encryption::verification::Verification::SasV1(sas) = verification
103:                 {
104:                     tracing::info!(
105:                         sender = %ev.sender,
106:                         "Accepting SAS verification request"
107:                     );
108:                     sas.accept().await.expect("Can't accept SAS verification");
109:                     // Auto-confirm emojis (for bot use - in production you'd want manual confirmation)
110:                     tokio::spawn(async move {
111:                         let mut stream = sas.changes();
112:                         while let Some(state) = stream.next().await {
113:                             use matrix_sdk::encryption::verification::SasState;
114:                             match state {
115:                                 SasState::KeysExchanged { emojis, .. } => {
116:                                     if let Some(emoji_list) = emojis {
117:                                         tracing::warn!(
118:                                             "üîê Emoji verification - Please verify these emojis match on the other device:"
119:                                         );
120:                                         for emoji in emoji_list.emojis.iter() {
121:                                             tracing::warn!(
122:                                                 emoji = emoji.symbol,
123:                                                 description = emoji.description,
124:                                                 "Emoji"
125:                                             );
126:                                         }
127:                                         tracing::warn!("Auto-confirming in 5 seconds...");
128:                                         tokio::time::sleep(tokio::time::Duration::from_secs(5))
129:                                             .await;
130:                                         sas.confirm()
131:                                             .await
132:                                             .expect("Can't confirm SAS verification");
133:                                     }
134:                                 }
135:                                 SasState::Done { .. } => {
136:                                     let device = sas.other_device();
137:                                     tracing::info!(
138:                                         user_id = %device.user_id(),
139:                                         device_id = %device.device_id(),
140:                                         "‚úÖ Successfully verified device"
141:                                     );
142:                                     break;
143:                                 }
144:                                 SasState::Cancelled(cancel_info) => {
145:                                     tracing::warn!(
146:                                         reason = cancel_info.reason(),
147:                                         "‚ùå Verification cancelled"
148:                                     );
149:                                     break;
150:                                 }
151:                                 _ => (),
152:                             }
153:                         }
154:                     });
155:                 }
156:             }
157:         },
158:     );
159:     tracing::info!("Message and verification handlers registered");
160:     // Start webhook server in background
161:     let webhook_port = webhook_config.webhook.port;
162:     let webhook_store = (*webhook_session_store).clone();
163:     let webhook_client = client.clone();
164:     let webhook_config_arc = Arc::clone(&webhook_config);
165:     tokio::spawn(async move {
166:         if let Err(e) = webhook::start_webhook_server(
167:             webhook_port,
168:             webhook_store,
169:             webhook_client,
170:             webhook_config_arc,
171:         )
172:         .await
173:         {
174:             tracing::error!(error = %e, "Webhook server failed");
175:         }
176:     });
177:     tracing::info!("Starting sync loop");
178:     // Sync forever
179:     client.sync(SyncSettings::default()).await?;
180:     Ok(())
181: }
</file>

<file path="src/lib.rs">
1: // ABOUTME: Root library module exposing all public modules
2: // ABOUTME: Provides access to config, session, claude, matrix client, and webhook modules
3: pub mod claude;
4: pub mod config;
5: pub mod matrix_client;
6: pub mod message_handler;
7: pub mod session;
8: pub mod webhook;
</file>

</files>
